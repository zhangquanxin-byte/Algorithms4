​							

# 							面试题精选

**面向对象和面向过程的区别**

1. 面向过程：

一种较早的编程思想，顾名思义就是该思想是站着过程的角度思考问题，强调的就是功能行为，功

能的执行过程，即先后顺序，而每一个功能我们都使用函数（类似于方法）把这些步骤一步一步实

现。使用的时候依次调用函数就可以了。

\2. 面向对象： 一种基于面向过程的新编程思想，顾名思义就是该思想是站在对象的角度思考问题，

我们把多个功能合理放到不同对象里，强调的是具备某些功能的对象。

具备某种功能的实体，称为对象。面向对象最小的程序单元是：类。面向对象更加符合常规的思维

方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。

在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚





## **Java**中有几种数据类型

整形：byte,short,int,long 浮点型：flfloat,double 字符型：char 

布尔型：boolean

基本类型	大小	取值范围	装箱基本类型
int	4个字节	-2^31 ~ 2^31-1	Integer
char	2个字节	 	Character
byte	1个字节	-2^7 ~ 2^7-1	Byte
short	2个字节	-2^15 ~ 2^15-1	Short
long	8个字节	-2^63 ~ 2^63-1	Long
float	4个字节	 	Float
double	8个字节	 	Double
boolean	1或者4个字节	true ~ false	Boolean

取值范围





## Integer默认存储-128到127的整数

```
内部静态类缓存了数组

private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high >= 127;
    }

    private IntegerCache() {}
}
```





**19****、面向对象的特征有哪些方面****?**

抽象:

抽象是将一类对象的共同特征总结出来构造类的过程, 包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为,并不关注这些行为的细节是什么。

继承:

继承是从已有类得到继承信息创建新类的过程.提供继承信息的类被称为父类(超类、基类) ;得到继承信息的类被称为子类(派生类)。继承让变化中的软件系统有了一定的延续性 ,同时继承也是封装程序中可变因素的重要

手段

封装：

通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问

只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自

治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写

一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，

只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，

明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是

封装得足够好的，因为几个按键就搞定了所有的事情）。

多态性：

多态性是指允许不同子类型的对象对同一消息作出不同的响应。

简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分

为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的

服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B

系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须

刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，

甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道

供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载

（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）

实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的

东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已

有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样

的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。





## java中的包有哪些



java.math

math****类有那些常用方法？**

Pow()：幂运算 Sqrt()：平方根 Round()：四舍五入 Abs()：求绝对值 Random()：生成一个0-1的随机

数，包括0不包括1



## Object类常用方法有那些？



Equals 

Hashcode 

https://blog.csdn.net/fenglibing/article/details/8905007

1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；

2、如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；

3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；

4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。





toString 

wait 

notify 

clone 

getClass





## **形参与实参区别**

**实参****(argument)****：**

全称为"实际参数"是在调用时传递给函数的参数. 实参可以是常量、变量、表达式、函数等， 无论实参

是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应

预先用赋值，输入等办法使实参获得确定值。 

**形参****(parameter)****：**

全称为"形式参数" 由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用

的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意

实参的个数，类型应与形参一一对应，并且实参必须要有确定的值。

形参出现在**函数定义**中，在整个函数体内都可以使用， 离开该函数则不能使用。

实参出现在**主调函数中，进入被调函数后，实参变量也不能使用**。

形参和实参的功能是作数据传送。发生函数调用时， **主调函数把实参的值传送给被调函数的形参从而实**

**现主调函数向被调函数的数据传送**。

1.形参变量只有在被调用时才分配内存单元，**在调用结束时， 即刻释放所分配的内存单元**。因此，形参

只有在函数内部有效。 函数调用结束返回

主调函数后则不能再使用该形参变量。

2.实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必

须具有确定的值， 以便把这些值传送给形

参。 因此应预先用赋值，输入等办法使实参获得确定值。

3.实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。

 https://www.ycbbs.vip4.**函数调用中发生的数据传送是单向的**。 即只能把实参的值传送给形参，而不能把形参的值反向地传送

给实参。 因此在函数调用过程中，形参的值

发生改变，而实参中的值不会变化。

5.当形参和实参不是指针类型时，在该函数运行时，**形参和实参是不同的变量，他们在内存中位于不同**

**的位置，形参将实参的内容复制一份，在该**

**函数运行结束的时候形参被释放，而实参内容不会改变**。 

而**如果函数的参数是指针类型变量**,**在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使**

**用的也是实参的地址，即使用的就是实参**

**本身**。所以在函数体内部可以改变实参的值。





## **内部类与静态内部类的区别？**

静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访

问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、

调用静态的方法；

普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方

法。

如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访

问属性或者调用方法。

如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个普通内

部类的对象作为一个属性，外同类可以通过该属性调用普通内部类的方法或者访问普通内部类的属性

如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类对象即





## 类的初始化顺序：

如果类还没有被加载： 
**1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。** 
**2、执行子类的静态代码块和静态变量初始化。** 
**3、执行父类的实例变量初始化** **，普通代码块。变量和代码块执行顺序和代码顺序一致。**
**4、执行父类的构造函数** 
**5、执行子类的实例变量初始化** **，普通代码块。变量和代码块执行顺序和代码顺序一致。**
**6、执行子类的构造函数** 

如果类已经被加载： 
**则静态代码块和静态变量就不用重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。**







## String,StringBuffer与StringBuilder的区别



String的值是不可变的，这就导致每次对String的操作都会生成**新的String对象**

和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且**不产生新的未使用对象**





## java创建对象的几种方式

### 1、new

### 2、反射

```
1、方式1默认使用无参构造
Class<?> clz = Class.forName("test.java.zxj.test_project.User");
Object object = clz.newInstance();
System.out.println(object instanceof User);

2、通过获取构造器，来创建对象：
Class<?> clz = Class.forName("test.java.zxj.test_project.User");
//获取参数为<String,String>的构造器
Constructor<?> constructor = clz.getConstructor(String.class, String.class);
Object object = constructor.newInstance("userId_001","name_jack");
if (object instanceof User) {
User user = (User)object;
System.out.println("userId:" + user.getUserId());
System.out.println("name:" + user.getName());
}

```

### 3.clone

```
public class Person implements Cloneable{

    private int age ;
    private String name;

    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return (Person)super.clone();
    }
}
```

*拷贝和浅拷贝的区别是什么*

浅拷贝

被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.

换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.

深拷贝

被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对

象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.



### 4、序列化和反序列化

#### 方式一：通过文件

所谓的序列化：就是把对象通过流的方式存储到文件中.注意：此对象 要重写Serializable 接口才能被序列化

```
ObjectOutputStream obji = new ObjectOutputStream(new FileOutputStream("Object1.txt"));
        Teacher teacher = new Teacher();
        teacher.setName("张三");
        teacher.setAge(20);
 
        obji.writeObject(teacher);

```

注:如果没有实现Serializable接口，会出现NotSerializableException
       1）要求对象中的所有属性也都是可以序列化
       2）如果某个属性不想序列化，可以在属性上加`transient`关键字

反序列化:

把字节内容读取进来，还原为java对象
         ObjectInputStream用来读取字节内容，还原（反序列化）为java对象



```
 ObjectInputStream Obji = new ObjectInputStream(new FileInputStream("Object1.txt"));
 Teacher t =(Teacher) Obji.readObject();
 System.out.println(t.getName()+t.getAge());

```

除了可以写入和读取对象以外，还可以写入和读取基本类型（int,long,boolean...) ，读取和写入的顺序要保持一致
如果不一致，出现EOFException如果没有更多内容，也会出现EOFException。建议在写入时最后一个对象使用null，这样读取时就可以根据null来判断是否读取完毕

序列化和反序列化其实也是java中的一种数据传输的机制



#### 方式二：通过内存（推荐）

```
import java.io.ByteArrayInputStream; 
import java.io.ByteArrayOutputStream; 
import java.io.ObjectInputStream; 
import java.io.ObjectOutputStream; 
import java.io.Serializable; 
public class MyUtil { 
    private MyUtil() { 
    	throw new AssertionError(); 
    }
    @SuppressWarnings("unchecked") 
	public static <T extends Serializable> T clone(T obj) throws Exception { 				ByteArrayOutputStream bout = new ByteArrayOutputStream(); 
	ObjectOutputStream oos = new ObjectOutputStream(bout); 
	oos.writeObject(obj); 
	ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); 				ObjectInputStream ois = new ObjectInputStream(bin); 
	return (T) ois.readObject(); 
// 说明：调用 ByteArrayInputStream 或 ByteArrayOutputStream对象的 close 方法没有任何 意义
// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的 释放 } }
```







## **JDBC**操作

### 连接步骤

加载数据库驱动类 打开数据库连接 执行sql语句 处理返回结果 关闭资源

### 数据库连接

数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接

的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空

闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。

### 怎么配置数据源：

```
 public static void main(String[] args) {
//配置文件
        HikariConfig hikariConfig = new HikariConfig();
//        hikariConfig.setJdbcUrl("jdbc:mysql://localhost:3306/mydata");//mysql
        hikariConfig.setJdbcUrl("jdbc:oracle:thin:@localhost:1521:orcl");//oracle
        hikariConfig.setDriverClassName("oracle.jdbc.driver.OracleDriver");
        hikariConfig.setUsername("whg");
        hikariConfig.setPassword("whg");
        hikariConfig.addDataSourceProperty("cachePrepStmts", "true");
        hikariConfig.addDataSourceProperty("prepStmtCacheSize", "250");
        hikariConfig.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
 
        HikariDataSource ds = new HikariDataSource(hikariConfig);
        Connection conn = null;
        Statement statement = null;
        ResultSet rs = null;
        try{
            
            //创建connection
            conn = ds.getConnection();
            statement = conn.createStatement();
            
            //执行sql
            rs = statement.executeQuery("select 100 s  from dual");
 
            //取数据
            if (rs.next()){
                System.out.println(rs.getString("s"));
            }
            
            //关闭connection
            conn.close();
        }
        catch (SQLException e){
            e.printStackTrace();
        }

```



### 怎么实现事务:

需要保证每个线程在一个事务中连的connection是同一个

```
public class TransactionUtil {
    private static ThreadLocal<Connection> threadLocal = new ThreadLocal<>() ;

    public static Connection getConnection() throws SQLException {
        Connection conn = threadLocal.get();//获取tl中的变量，如果不够，会自动创建副本
        if(conn == null){
            conn = DataSourceUtil.getDataSourceWithC3P0().getConnection();
            //System.out.println("从连接池获取连接！链接："+conn+"线程名称"+Thread.currentThread().getName());
            threadLocal.set(conn);
        }
        return conn;
    }

    //开启事务
    public static void beginTransaction() throws SQLException {
       //连接
        Connection conn =  getConnection() ;
        conn.setAutoCommit(false);//开启事务

    }

    //正常。提交事务
    public static void commitTransaction() throws SQLException {
        //连接
        Connection conn =  getConnection() ;
        //所有的 对象.方法()  全部排空
        if(conn !=null)
            conn.commit();

    }

    //失败。回滚事务
    public static void rollbackTransaction() throws SQLException {
        //连接
        Connection conn =  getConnection() ;
        if(conn !=null)
            conn.rollback();
    }

```





## Java中的编译期常量是什么？使用它又什么风险？

公共静态不可变（public static fifinal ）变量也就是我们所说的编译期常量，这里的 public 可选的。实

际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改

变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面

被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了避免这种

情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序



## **抽象类（****abstract class****）和接口（****interface****）有什么异同 ？**

抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或

者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比

抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造

器而且其中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、public 的，

而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是

常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。





## 四种元注解

@Target 表示该注解用于什么地方，可能的值在枚举类 ElemenetType 中，包括：

     ElemenetType.CONSTRUCTOR-----------------------------构造器声明 
     ElemenetType.FIELD ----------------------------------域声明（包括 enum 实例） 
     ElemenetType.LOCAL_VARIABLE------------------------- 局部变量声明 
     ElemenetType.METHOD ---------------------------------方法声明 
     ElemenetType.PACKAGE --------------------------------包声明 
     ElemenetType.PARAMETER ------------------------------参数声明 
     ElemenetType.TYPE----------------------------------- 类，接口（包括注解类型）或enum声明 


@Retention 表示在什么级别保存该注解信息。可选的参数值在枚举类型 RetentionPolicy 中，包括：

     RetentionPolicy.SOURCE-------------注解将被编译器丢弃 
     RetentionPolicy.CLASS -------------注解在class文件中可用，但会被VM丢弃 
     RetentionPolicy.RUNTIME ---------VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。


@Documented 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当与@see,@param 等。

@Inherited 允许子类继承父类中的注解。
