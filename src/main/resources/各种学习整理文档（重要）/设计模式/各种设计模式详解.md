## 1、工厂设计模式+模板设计模式

**模板方法模式：**定义一个操作中的算法的框架,而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。通俗的讲，就是将子类相同的方法，都放到其抽象父类中。

**工厂模式：**工厂方法模式是一种创建对象的模式，它被广泛应用在 jdk 中以及 Spring 和 Struts 框架中。它将创建对象的工作转移到了工厂类。



**模板抽到父类（抽象类）中**。至于特定的步骤实现不一样，这些特殊步骤，由子类去重写

```java
public abstract class AbstractDataSourceProcesser <T extends QueryInputDomain> {
    public List<HashMap> query(T params){
        List<HashMap> list = new ArrayList<>();
        //检验参数合法性 不同的引擎sql校验逻辑不一样
        Boolean b = checkParam(params);
        if(b){
            //查询
            list = queryData(params);
        }
        //记录日志
        log.info("用户={} 查询数据源={} 结果size={}",params.getUserName(),params.getDataSource(),list.size());
        return list;
    }
    //抽象方法 由子类来实现特定逻辑
    abstract Boolean checkParam(T params);
    abstract List<HashMap> queryData(T params);
}
```

为了不重复冗余，更好的利用公共资源及规范入参，在泛型的设计上，我们可以有一个泛型上限，<T extends QueryInputDomain>：

```java
public class QueryInputDomain<T> {
    public String userName;//查询用户名
    public String dataSource;//查询数据源 比如mysql\tidb等
    public T params;//特定的参数 不同的数据源参数一般不一样
}
public class MysqlQueryInput extends QueryInputDomain{
    private String database;//数据库
    public String sql;//sql
}
```

**子类继承父类，重写 checkParam() 和 queryData() 方法。**

```java
@Component("dataSourceProcessor#mysql")
public class MysqlProcesser extends AbstractDataSourceProcesser<MysqlQueryInput>{
    @Override
    public Boolean checkParam(MysqlQueryInput params) {
        System.out.println("检验mysql参数是否准确");
        return true;
    }

    @Override
    public List<HashMap> queryData(MysqlQueryInput params) {
        List<HashMap> list = new ArrayList<>();
        System.out.println("开始查询mysql数据");
        return list;
    }
}
```



**最后一步：怎么调用每个子类的service类**

方法1、spring

方法2、java反射

```java
public static String classPrefix = "com.lyl.java.advance.service.";

AbstractDataSourceProcesser sourceGenerator = 
(AbstractDataSourceProcesser) Class.forName
(classPrefix+DataSourceEnum.getClasszByCode(domain.getDataSource()))
.newInstance();
```

该种方法是通过 className 来获取到类的实例，而前端传参肯定是不会传 className 过来的。

因此可以用到枚举类，去定义好不同数据源的类名：

```java
ublic enum DataSourceEnum {
    mysql("mysql", "MysqlProcesser"),
    tidb("tidb", "TidbProcesser"),
    db2("db2", "DB2Processer");


    private String code;
    private String name;

    private DataSourceEnum(String code, String name) {
        this.code = code;
        this.name = name;
    }

    public String getCode() {
        return code;
    }

    public String getName() {
        return name;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public void setName(String name) {
        this.name = name;
    }

    public static String getClasszByCode(String code){
        DataSourceEnum[] values = DataSourceEnum.values();
        for (DataSourceEnum value : values) {
            if (value.getCode().equals(code)){
                System.out.println(value.getCode());
                System.out.println(value.getName());
                return value.getName();
            }
        }
        return "不存在";
    }

}
```







## 2、适配器模式

### **适配器**

适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。

在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。

根据适配器类与适配者类的关系不同，适配器模式可分为**对象适配器**和**类适配器**两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。


### 角色

**Target（目标抽象类）**：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。

**Adapter（适配器类）**：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。

**Adaptee（适配者类）**：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。

实例：可以有两种方法直接使用继承如下或者使用组合+接口（推荐）

目标抽象类:Readable接口    

适配者类

```java
public class RandomChars {
    private static  Random  random=new Random(47);
    public  static final char[] charSeq="ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
    public String create4Str(){
        String st="";
        for (int i = 0; i <4 ; i++) {
            st+=charSeq[random.nextInt(charSeq.length)];
        }
        return st;
    }
}
```

适配器类

```java
public class AdaptedRandomChars extends RandomChars implements Readable {
    private int count;

    public AdaptedRandomChars(int count) {
        this.count = count;
    }

    @Override
    public int read(CharBuffer cb) throws IOException {
        if (count--==0){
            return -1;
        }
        cb.append(create4Str());
        cb.append(" ");
        return 5;//输出的字符串长度
    }
}
```

使用

```java
public class TestMain {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(new AdaptedRandomChars(10));
        while (scanner.hasNext()) {
            System.out.println(scanner.next());
            System.out.println();
        }
    }
}
```





## 3、工厂方法模式

1. 在面向对象编程中, 最通常的方法是一个new操作符产生一个对象实例,new操作符就是用来构造对象实例的。但是在一些情况下, new操作符直接生成对象会带来一些问题。举例来说, 许多类型对象的创造需要一系列的步骤: 你可能需要计算或取得对象的初始设置; 选择生成哪个子对象实例; 或在生成你需要的对象之前必须先生成一些辅助功能的对象。 在这些情况,新对象的建立就是一个 “过程”，不仅是一个操作，像一部大机器中的一个齿轮传动。

   

  **模式的问题**：你如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程呢？

  **解决方案**：建立一个工厂来创建对象

  **实现：**

  **一、引言**
    1）还没有工厂时代：假如还没有工业革命，如果一个客户要一款宝马车,一般的做法是客户去创建一款宝马车，然后拿来用。
    2）简单工厂模式：后来出现工业革命。用户不用去创建宝马车。因为客户有一个工厂来帮他创建宝马.想要什么车，这个工厂就可以建。比如想要320i系列车。工厂就创建这个系列的车。即工厂可以创建产品。
    3）工厂方法模式时代：为了满足客户，宝马车系列越来越多，如320i，523i,30li等系列一个工厂无法创建所有的宝马系列。于是由单独分出来多个具体的工厂。每个具体工厂创建一种系列。即具体工厂类只能创建一个具体产品。但是宝马工厂还是个抽象。你需要指定某个具体的工厂才能生产车出来。

4）抽象工厂模式时代：随着客户的要求越来越高，宝马车必须配置空调。于是这个工厂开始生产宝马车和需要的空调。最终是客户只要对宝马的销售员说：我要523i空调车，销售员就直接给他523i空调车了。而不用自己去创建523i空调车宝马车.

这就是工厂模式。

  **二、分类** 
      工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 
  工厂模式可以分为三类： 

  1）简单工厂模式（Simple Factory） 
  2）工厂方法模式（Factory Method） 
  3）抽象工厂模式（Abstract Factory） 

   这三种模式从上到下逐步抽象，并且更具一般性。 
      GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。

  ​    将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。 

  **三、区别** 
  工厂方法模式：
  一个抽象产品类，可以派生出多个具体产品类。  
  一个抽象工厂类，可以派生出多个具体工厂类。  
  每个具体工厂类只能创建一个具体产品类的实例。
  抽象工厂模式：
  多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。  
  一个抽象工厂类，可以派生出多个具体工厂类。  
  每个具体工厂类可以创建多个具体产品类的实例。  
  区别：
  工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。  
  工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
  两者皆可。 

   **四、简单工厂模式** 
  建立一个工厂（一个函数或一个类方法）来制造新的对象。
  分布说明引子：从无到有。客户自己创建宝马车，然后拿来用。

   ![img](https://img-blog.csdn.net/20140406222017625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFzb24wNTM5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   

  ```java
  public class BMW320 {
  	public BMW320(){
  		System.out.println("制造-->BMW320");
  	}
  }
  public class BMW523 {
  
  	public BMW523(){
  		System.out.println("制造-->BMW523");
  	}
  
  }
  
  
  public class Customer {
  	public static void main(String[] args) {
  
  		BMW320 bmw320 = new BMW320();
  
  		BMW523 bmw523 = new BMW523();
  
  	}
  
  }
  ```

  **客户需要知道怎么去创建一款车,客户和车就紧密耦合在一起了.为了降低耦合**,就出现了工厂类,把创建宝马的操作细节都放到了工厂里面去,客户直接使用工厂的创建工厂方法,传入想要的宝马车型号就行了,而不必去知道创建的细节.这就是工业革命了：**简单工厂模式**

  即我们建立一个工厂类方法来制造新的对象。如图：

  ![img](https://img-blog.csdn.net/20140406222216734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFzb24wNTM5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

  产品类：

  ```java
  
  abstract class BMW {
  	public BMW(){
  		
  	}
  }
   
  public class BMW320 extends BMW {
  	public BMW320() {
  		System.out.println("制造-->BMW320");
  	}
  }
  public class BMW523 extends BMW{
  	public BMW523(){
  		System.out.println("制造-->BMW523");
  	}
  }
  ```

  工厂类：

  ```java
  
  public class Factory {
  	public BMW createBMW(int type) {
  		switch (type) {
  		
  		case 320:
  			return new BMW320();
   
  		case 523:
  			return new BMW523();
   
  		default:
  			break;
  		}
  		return null;
  	}
  }
  ```


  客户类：

  ```java
  public class Customer {
  	public static void main(String[] args) {
  		Factory factory = new Factory();
  		BMW bmw320 = factory.createBMW(320);
  		BMW bmw523 = factory.createBMW(523);
  	}
  }
  ```

    简单工厂模式又称静态工厂方法模式。从命名上就可以看出这个模式一定很简单。它存在的目的很简单：定义一个用于创建对象的接口。 
     先来看看它的组成： 
       1) 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品
       2) 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。     
       3) 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 
      
      下面我们从开闭原则（对扩展开放；对修改封闭）上来分析下简单工厂模式。当客户不再满足现有的车型号的时候，想要一种速度快的新型车，只要这种车符合抽象产品制定的合同，那么只要通知工厂类知道就可以被客户使用了。所以对产品部分来说，它是符合开闭原则的；但是工厂部分好像不太理想，**因为每增加一种新型车，都要在工厂类中增加相应的创建业务逻辑（createBMW(int type)方法需要新增case），这显然是违背开闭原则的**。可想而知对于新产品的加入，工厂类是很被动的。对于这样的工厂类，我们称它为全能类或者上帝类。 
       我们举的例子是最简单的情况，而在实际应用中，很可能产品是一个多层次的树状结构。由于简单工厂模式中只有一个工厂类来对应这些产品，所以这可能会把我们的上帝累坏了，也累坏了我们这些程序员。
      于是工厂方法模式作为救世主出现了。 工厂类定义成了接口,而每新增的车种类型,就增加该车种类型对应工厂类的实现,这样工厂的设计就可以扩展了,而不必去修改原来的代码。
  **五、工厂方法模式** 
      工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担。 
  工厂方法模式组成： 
      1)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
      2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 
      3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
      4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 
      工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活起来——当有新的产品产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有 的代码。可以看出工厂角色的结构也是符合开闭原则的！ 

  代码如下： 

  产品类：

  ```java
  
  abstract class BMW {
  	public BMW(){
  		
  	}
  }
  public class BMW320 extends BMW {
  	public BMW320() {
  		System.out.println("制造-->BMW320");
  	}
  }
  public class BMW523 extends BMW{
  	public BMW523(){
  		System.out.println("制造-->BMW523");
  	}
  }
  ```


  创建工厂类：

  ```java
  interface FactoryBMW {
  	BMW createBMW();
  }
   
  public class FactoryBMW320 implements FactoryBMW{
   
  	@Override
  	public BMW320 createBMW() {
   
  		return new BMW320();
  	}
   
  }
  public class FactoryBMW523 implements FactoryBMW {
  	@Override
  	public BMW523 createBMW() {
   
  		return new BMW523();
  	}
  }
  ```


  客户类：

  ```java
  public class Customer {
  	public static void main(String[] args) {
  		FactoryBMW320 factoryBMW320 = new FactoryBMW320();
  		BMW320 bmw320 = factoryBMW320.createBMW();
   
  		FactoryBMW523 factoryBMW523 = new FactoryBMW523();
  		BMW523 bmw523 = factoryBMW523.createBMW();
  	}
  }
  ```


   工厂方法模式仿佛已经很完美的对对象的创建进行了包装，使得客户程序中仅仅处理抽象产品角色提供的接口，但使得对象的数量成倍增长。当产品种类非常多时，会出现大量的与之对应的工厂对象，这不是我们所希望的。

### 抽象工厂模式

例子背景：

随着客户的要求越来越高，宝马车需要不同配置的空调和发动机等配件。于是这个工厂开始生产空调和发动机，用来组装汽车。这时候工厂有两个系列的产品:空调和发动机。 宝马320系列配置A型号空调和A型号发动机，宝马230系列配置B型号空调和B型号发动机。

概念：

  抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。比如宝马320系列使用空调型号A和发动机型号A，而宝马230系列使用空调型号B和发动机型号B，那么使用抽象工厂模式，在为320系列生产相关配件时，就无需制定配件的型号，它会自动根据车型生产对应的配件型号A。

针对百度百科上对于抽象工厂模式的简介，结合本例如下：

当每个抽象产品都有多于一个的具体子类的时候（空调有型号A和B两种，发动机也有型号A和B两种），工厂角色怎么知道实例化哪一个子类呢？比如每个抽象产品角色都有两个具体产品（产品空调有两个具体产品空调A和空调B）。抽象工厂模式提供两个具体工厂角色（宝马320系列工厂和宝马230系列工厂），分别对应于这两个具体产品角色，每一个具体工厂角色只负责某一个产品角色的实例化。每一个具体工厂类只负责创建抽象产品的某一个具体子类的实例。

**抽象工厂模式代码**

 产品类： 



```java
//发动机以及型号  
public interface Engine {  
 
}  
public class EngineA extends Engine{  
    public EngineA(){  
        System.out.println("制造-->EngineA");  
    }  
}  
public class EngineB extends Engine{  
    public EngineB(){  
        System.out.println("制造-->EngineB");  
    }  
}  
 
//空调以及型号  
public interface Aircondition {  
 
}  
public class AirconditionA extends Aircondition{  
    public AirconditionA(){  
        System.out.println("制造-->AirconditionA");  
    }  
}  
public class AirconditionB extends Aircondition{  
    public AirconditionB(){  
        System.out.println("制造-->AirconditionB");  
    }  
} 
```




创建工厂类：

```java
//创建工厂的接口  
public interface AbstractFactory {  
    //制造发动机
    public Engine createEngine();
    //制造空调 
    public Aircondition createAircondition(); 
}  
 
 
//为宝马320系列生产配件  
public class FactoryBMW320 implements AbstractFactory{  
      
    @Override  
    public Engine createEngine() {    
        return new EngineA();  
    }  
    @Override  
    public Aircondition createAircondition() {  
        return new AirconditionA();  
    }  
}  
//宝马523系列
public class FactoryBMW523 implements AbstractFactory {  
  
     @Override  
    public Engine createEngine() {    
        return new EngineB();  
    }  
    @Override  
    public Aircondition createAircondition() {  
        return new AirconditionB();  
    }  
 
 
} 
```





客户:

```java
public class Customer {  
    public static void main(String[] args){  
        //生产宝马320系列配件
        FactoryBMW320 factoryBMW320 = new FactoryBMW320();  
        factoryBMW320.createEngine();
        factoryBMW320.createAircondition();
          
        //生产宝马523系列配件  
        FactoryBMW523 factoryBMW523 = new FactoryBMW523();  
        factoryBMW320.createEngine();
        factoryBMW320.createAircondition();
    }  
}
```


关于抽象工厂模式与工厂方法模式的区别，这里就不说了，感觉多看几遍例子就能理解，还有很多提到的产品族、等级结构等概念，说了反而更难理解。



**抽象工厂模式的起源**

下面引用一段[抽象工厂模式](http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html)的起源：

抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如：命令按键（Button）与文字框（Text)都是视窗构建，在UNIX操作系统的视窗环境和Windows操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。

在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是Button和Text组成的产品族。而每一个视窗构件都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。

![img](https://img-blog.csdn.net/20150410110918027?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFzb24wNTM5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

可以发现在上面的产品类图中，有两个产品的等级结构，分别是Button等级结构和Text等级结构。同时有两个产品族，也就是UNIX产品族和Windows产品族。UNIX产品族由UNIX Button和UNIX Text产品构成；而Windows产品族由Windows Button和Windows Text产品构成。

![img](https://img-blog.csdn.net/20150410111021890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFzb24wNTM5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

系统对产品对象的创建需求由一个工程的等级结构满足，其中有两个具体工程角色，即UnixFactory和WindowsFactory。UnixFactory对象负责创建Unix产品族中的产品，而WindowsFactory对象负责创建Windows产品族中的产品。这就是抽象工厂模式的应用，抽象工厂模式的解决方案如下图：

![img](https://img-blog.csdn.net/20150410110953938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFzb24wNTM5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

显然，一个系统只能够在某一个操作系统的视窗环境下运行，而不能同时在不同的操作系统上运行。所以，系统实际上只能消费属于同一个产品族的产品。

在现代的应用中，抽象工厂模式的使用范围已经大大扩大了，不再要求系统只能消费某一个产品族了。

总结：

无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。

​    所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。







## 4单例模式

### 懒汉模式：

1、volatile 关键字：防止指令重排导致部分对象初始化问题

2、synchronized关键字双重检查锁

3、构造方法私有化

```
public class XStreamFactory {
	private static volatile XStreamFactory instance = null;
    public static XStreamFactory getInstance()
    {

        if (instance == null)
        {
        //(Double Check Lock，双重检查锁）机制，使得大部分请求都不会进入阻塞代码块：
            synchronized (XStreamFactory.class)
            {
                if (instance == null)
                {
                    instance = new XStreamFactory();
                }
            }
        }

        return instance;
    }
    //构造方法私有化
    private XStreamFactory() {
    }
 }
```

#### 指令重排序问题

**当instance不为null时，仍可能指向一个`"被部分初始化的对象问题：**

这行简单的赋值语句：

```java
instance = new Singleton();
```

它并不是一个原子操作。事实上，它可以”抽象“为下面几条JVM指令：

```java
memory = allocate();	//1：分配对象的内存空间
initInstance(memory);	//2：初始化对象
instance = memory;		//3：设置instance指向刚分配的内存地址
```

上面*操作2依赖于操作1，但是操作3并不依赖于操作2*，所以JVM可以以“优化”为目的对它们进行`重排序`，经过重排序后如下：

```java
memory = allocate();	//1：分配对象的内存空间
instance = memory;		//3：设置instance指向刚分配的内存地址（此时对象还未初始化）
ctorInstance(memory);	//2：初始化对象
```

可以看到指令重排之后，操作 3 排在了操作 2 之前，即**引用instance指向内存memory时，这段崭新的内存还没有初始化**——即，引用instance指向了一个"被部分初始化的对象"。此时，如果另一个线程调用getInstance方法，*由于instance已经指向了一块内存空间，从而if条件判为false，方法返回instance引用*，用户得到了没有完成初始化的“半个”单例。



#### 解决：volatile

volatile关键字通过`“内存屏障”`来防止指令被重排序。

为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。





## 5、代理设计模式

### **什么是代理模式？**

​    **代理模式的定义：**代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。



### **哪几种代理模式？**

​    我们有多种不同的方式来实现代理。如果按照代理创建的时期来进行分类的话， 可以分为两种：静态代理、动态代理。静态代理是由程序员创建或特定工具自动生成源代码，在对其编译。在程序员运行之前，代理类.class文件就已经被创建了。动态代理是在程序运行时通过反射机制动态创建的。

#### **1.静态代理**   

 **第****一步：创建服务类接口**

```
 1 package main.java.proxy;
 2 
 3 /**
 4  * @Auther: dan gao
 5  * @Description:
 6  * @Date: 22:40 2018/1/9 0009
 7  */
 8 public interface BuyHouse {
 9     void buyHosue();
10 }
```



**第二步：实现服务接口**

```
 1 import main.java.proxy.BuyHouse;
 2 
 3 /**
 4  * @Auther: dan gao
 5  * @Description:
 6  * @Date: 22:42 2018/1/9 0009
 7  */
 8 public class BuyHouseImpl implements BuyHouse {
 9 
10     @Override
11     public void buyHosue() {
12         System.out.println("我要买房");
13     }
14 }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**第三步：创建代理类**

```
 1 package main.java.proxy.impl;
 2 
 3 import main.java.proxy.BuyHouse;
 4 
 5 /**
 6  * @Auther: dan gao
 7  * @Description:
 8  * @Date: 22:43 2018/1/9 0009
 9  */
10 public class BuyHouseProxy implements BuyHouse {
11 
12     private BuyHouse buyHouse;
13 
14     public BuyHouseProxy(final BuyHouse buyHouse) {
15         this.buyHouse = buyHouse;
16     }
17 
18     @Override
19     public void buyHosue() {
20         System.out.println("买房前准备");
21         buyHouse.buyHosue();
22         System.out.println("买房后装修");
23 
24     }
25 }
```



**第四步：编写测试类**

```
import main.java.proxy.impl.BuyHouseImpl;
import main.java.proxy.impl.BuyHouseProxy;

/**
 * @Auther: dan gao
 * @Description:
 * @Date: 22:43 2018/1/9 0009
 */
public class ProxyTest {
    public static void main(String[] args) {
        BuyHouse buyHouse = new BuyHouseImpl();
        buyHouse.buyHosue();
        BuyHouseProxy buyHouseProxy = new BuyHouseProxy(buyHouse);
        buyHouseProxy.buyHosue();
    }
}
```

**静态代理总结：**

优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。

缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。    



#### **2.动态代理**

　　在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。

**第一步：编写动态处理器**

```
 1 package main.java.proxy.impl;
 2 
 3 import java.lang.reflect.InvocationHandler;
 4 import java.lang.reflect.Method;
 5 
 6 /**
 7  * @Auther: dan gao
 8  * @Description:
 9  * @Date: 20:34 2018/1/12 0012
10  */
11 public class DynamicProxyHandler implements InvocationHandler {
12 
13     private Object object;
14 
15     public DynamicProxyHandler(final Object object) {
16         this.object = object;
17     }
18 
19     @Override
20     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
21         System.out.println("买房前准备");
22         Object result = method.invoke(object, args);
23         System.out.println("买房后装修");
24         return result;
25     }
26 }
```



**第二步：编写测试类**

```
 1 package main.java.proxy.test;
 2 
 3 import main.java.proxy.BuyHouse;
 4 import main.java.proxy.impl.BuyHouseImpl;
 5 import main.java.proxy.impl.DynamicProxyHandler;
 6 
 7 import java.lang.reflect.Proxy;
 8 
 9 /**
10  * @Auther: dan gao
11  * @Description:
12  * @Date: 20:38 2018/1/12 0012
13  */
14 public class DynamicProxyTest {
15     public static void main(String[] args) {
16         BuyHouse buyHouse = new BuyHouseImpl();
17         BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new
18                 Class[]{BuyHouse.class}, new DynamicProxyHandler(buyHouse));
19         proxyBuyHouse.buyHosue();
20     }
21 }
```

 注意*Proxy.newProxyInstance()*方法接受三个参数：

- *`ClassLoader loader`:*指定当前目标对象使用的类加载器,获取加载器的方法是固定的
- *`Class[] interfaces`:*指定目标对象实现的接口的类型,使用泛型方式确认类型
- *`InvocationHandler:`*`指定动态处理器，`执行目标对象的方法时,会触发事件处理器的方法

**动态代理总结：**虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。



### **3.CGLIB代理**

​    JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。

**第一步：创建CGLIB代理类**

```
 1 package dan.proxy.impl;
 2 
 3 import net.sf.cglib.proxy.Enhancer;
 4 import net.sf.cglib.proxy.MethodInterceptor;
 5 import net.sf.cglib.proxy.MethodProxy;
 6 
 7 import java.lang.reflect.Method;
 8 
 9 /**
10  * @Auther: dan gao
11  * @Description:
12  * @Date: 20:38 2018/1/16 0016
13  */
14 public class CglibProxy implements MethodInterceptor {
15     private Object target;
16     public Object getInstance(final Object target) {
17         this.target = target;
18         Enhancer enhancer = new Enhancer();
19         enhancer.setSuperclass(this.target.getClass());
20         enhancer.setCallback(this);
21         return enhancer.create();
22     }
23 
24     public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
25         System.out.println("买房前准备");
26         Object result = methodProxy.invoke(object, args);
27         System.out.println("买房后装修");
28         return result;
29     }
30 }
```

 

**第二步：创建测试类**

```
 1 package dan.proxy.test;
 2 
 3 import dan.proxy.BuyHouse;
 4 import dan.proxy.impl.BuyHouseImpl;
 5 import dan.proxy.impl.CglibProxy;
 6 
 7 /**
 8  * @Auther: dan gao
 9  * @Description:
10  * @Date: 20:52 2018/1/16 0016
11  */
12 public class CglibProxyTest {
13     public static void main(String[] args){
14         BuyHouse buyHouse = new BuyHouseImpl();
15         CglibProxy cglibProxy = new CglibProxy();
16         BuyHouseImpl buyHouseCglibProxy = (BuyHouseImpl) cglibProxy.getInstance(buyHouse);
17         buyHouseCglibProxy.buyHosue();
18     }
19 }
```



**CGLIB代理总结：** CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。



### 编写数据库连接池

　　**编写连接池需实现java.sql.DataSource接口。**DataSource接口中定义了两个重载的getConnection方法：

- Connection getConnection()
- Connection getConnection(String username, String password)

　　实现DataSource接口，并实现连接池功能的步骤：

1. 在DataSource构造函数中批量创建与数据库的连接，并把创建的连接加入LinkedList对象中。
2. 实现getConnection方法，让getConnection方法每次调用时，从LinkedList中取一个Connection返回给用户。
3. 当用户使用完Connection，调用Connection.close()方法时，Collection对象应保证将自己返回到LinkedList中,而不要把conn还给数据库。**Collection保证将自己返回到LinkedList中是此处编程的难点**。

 数据库连接池核心代码

　　使用动态代理技术构建连接池中的connection

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 proxyConn = (Connection) Proxy.newProxyInstance(this.getClass()
 2             .getClassLoader(), conn.getClass().getInterfaces(),
 3             new InvocationHandler() {
 4         //此处为内部类，当close方法被调用时将conn还回池中,其它方法直接执行
 5             public Object invoke(Object proxy, Method method,
 6                       Object[] args) throws Throwable {
 7                 if (method.getName().equals("close")) {
 8                     pool.addLast(conn);
 9                     return null;
10             }
11             return method.invoke(conn, args);
12         }
13     });
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

数据库连接池编写范例：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
  1 package me.gacl.demo;
  2 
  3 import java.io.InputStream;
  4 import java.io.PrintWriter;
  5 import java.lang.reflect.InvocationHandler;
  6 import java.lang.reflect.Method;
  7 import java.lang.reflect.Proxy;
  8 import java.sql.Connection;
  9 import java.sql.DriverManager;
 10 import java.sql.SQLException;
 11 import java.util.LinkedList;
 12 import java.util.Properties;
 13 import javax.sql.DataSource;
 14 
 15 /**
 16 * @ClassName: JdbcPool
 17 * @Description:编写数据库连接池
 18 * @author: 孤傲苍狼
 19 * @date: 2014-9-30 下午11:07:23
 20 *
 21 */ 
 22 public class JdbcPool implements DataSource{
 23 
 24     /**
 25     * @Field: listConnections
 26     *         使用LinkedList集合来存放数据库链接，
 27     *        由于要频繁读写List集合，所以这里使用LinkedList存储数据库连接比较合适
 28     */ 
 29     private static LinkedList<Connection> listConnections = new LinkedList<Connection>();
 30     
 31     static{
 32         //在静态代码块中加载db.properties数据库配置文件
 33         InputStream in = JdbcPool.class.getClassLoader().getResourceAsStream("db.properties");
 34         Properties prop = new Properties();
 35         try {
 36             prop.load(in);
 37             String driver = prop.getProperty("driver");
 38             String url = prop.getProperty("url");
 39             String username = prop.getProperty("username");
 40             String password = prop.getProperty("password");
 41             //数据库连接池的初始化连接数大小
 42             int jdbcPoolInitSize =Integer.parseInt(prop.getProperty("jdbcPoolInitSize"));
 43             //加载数据库驱动
 44             Class.forName(driver);
 45             for (int i = 0; i < jdbcPoolInitSize; i++) {
 46                 Connection conn = DriverManager.getConnection(url, username, password);
 47                 System.out.println("获取到了链接" + conn);
 48                 //将获取到的数据库连接加入到listConnections集合中，listConnections集合此时就是一个存放了数据库连接的连接池
 49                 listConnections.add(conn);
 50             }
 51             
 52         } catch (Exception e) {
 53             throw new ExceptionInInitializerError(e);
 54         }
 55     }
 56     
 57     @Override
 58     public PrintWriter getLogWriter() throws SQLException {
 59         // TODO Auto-generated method stub
 60         return null;
 61     }
 62 
 63     @Override
 64     public void setLogWriter(PrintWriter out) throws SQLException {
 65         // TODO Auto-generated method stub
 66         
 67     }
 68 
 69     @Override
 70     public void setLoginTimeout(int seconds) throws SQLException {
 71         // TODO Auto-generated method stub
 72         
 73     }
 74 
 75     @Override
 76     public int getLoginTimeout() throws SQLException {
 77         // TODO Auto-generated method stub
 78         return 0;
 79     }
 80 
 81     @Override
 82     public <T> T unwrap(Class<T> iface) throws SQLException {
 83         // TODO Auto-generated method stub
 84         return null;
 85     }
 86 
 87     @Override
 88     public boolean isWrapperFor(Class<?> iface) throws SQLException {
 89         // TODO Auto-generated method stub
 90         return false;
 91     }
 92 
 93     /* 获取数据库连接
 94      * @see javax.sql.DataSource#getConnection()
 95      */
 96     @Override
 97     public Connection getConnection() throws SQLException {
 98         //如果数据库连接池中的连接对象的个数大于0
 99         if (listConnections.size()>0) {
100             //从listConnections集合中获取一个数据库连接
101             final Connection conn = listConnections.removeFirst();
102             System.out.println("listConnections数据库连接池大小是" + listConnections.size());
103             //返回Connection对象的代理对象
104             return (Connection) Proxy.newProxyInstance(JdbcPool.class.getClassLoader(), conn.getClass().getInterfaces(), new InvocationHandler(){
105                 @Override
106                 public Object invoke(Object proxy, Method method, Object[] args)
107                         throws Throwable {
108                     if(!method.getName().equals("close")){
109                         return method.invoke(conn, args);
110                     }else{
111                         //如果调用的是Connection对象的close方法，就把conn还给数据库连接池
112                         listConnections.add(conn);
113                         System.out.println(conn + "被还给listConnections数据库连接池了！！");
114                         System.out.println("listConnections数据库连接池大小为" + listConnections.size());
115                         return null;
116                     }
117                 }
118             });
119         }else {
120             throw new RuntimeException("对不起，数据库忙");
121         }
122     }
123 
124     @Override
125     public Connection getConnection(String username, String password)
126             throws SQLException {
127         return null;
128     }
129 }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 db.properties配置文件如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
1 driver=com.mysql.jdbc.Driver
2 url=jdbc:mysql://localhost:3306/jdbcStudy
3 username=root
4 password=XDP
5 
6 jdbcPoolInitSize=10
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

写一个JdbcUtil测试数据库连接池

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 package me.gacl.utils;
 2 
 3 import java.sql.Connection;
 4 import java.sql.ResultSet;
 5 import java.sql.SQLException;
 6 import java.sql.Statement;
 7 import me.gacl.demo.JdbcPool;
 8 
 9 public class JdbcUtil {
10     
11     /**
12     * @Field: pool
13     *          数据库连接池
14     */ 
15     private static JdbcPool pool = new JdbcPool();
16     
17     /**
18     * @Method: getConnection
19     * @Description: 从数据库连接池中获取数据库连接对象
20     * @Anthor:孤傲苍狼
21     * @return Connection数据库连接对象
22     * @throws SQLException
23     */ 
24     public static Connection getConnection() throws SQLException{
25         return pool.getConnection();
26     }
27     
28     /**
29     * @Method: release
30     * @Description: 释放资源，
31     * 释放的资源包括Connection数据库连接对象，负责执行SQL命令的Statement对象，存储查询结果的ResultSet对象
32     * @Anthor:孤傲苍狼
33     *
34     * @param conn
35     * @param st
36     * @param rs
37     */ 
38     public static void release(Connection conn,Statement st,ResultSet rs){
39         if(rs!=null){
40             try{
41                 //关闭存储查询结果的ResultSet对象
42                 rs.close();
43             }catch (Exception e) {
44                 e.printStackTrace();
45             }
46             rs = null;
47         }
48         if(st!=null){
49             try{
50                 //关闭负责执行SQL命令的Statement对象
51                 st.close();
52             }catch (Exception e) {
53                 e.printStackTrace();
54             }
55         }
56         
57         if(conn!=null){
58             try{
59                 //关闭Connection数据库连接对象
60                 conn.close();
61             }catch (Exception e) {
62                 e.printStackTrace();
63             }
64         }
65     }
66 }
```





## 6、策略模式

​		策略模式（Strategy Pattern）定义了一组同类型的算法，在不同的类中封装起来，每种算法可以根据当前场景相互替换，从而使算法的变化独立于使用它们的客户端（即算法的调用者）

例如：在网购中，我在支付的时候，可以根据实际情况来选择不同的支付方式（微信支付、支付宝、银行卡支付等等），这些支付方式即是不同的策略。我们通常会看到如下的实现代码：

```text
Order order = 订单信息
if (payType == 微信支付) {
    微信支付流程
} else if (payType == 支付宝) {
    支付宝支付流程
} else if (payType == 银行卡) {
    银行卡支付流程
} else {
    暂不支持的支付方式
}
```

如上代码，虽然写起来简单，但违反了面向对象的 2 个基本原则：

- `单一职责原则`：一个类只有1个发生变化的原因
  之后修改任何逻辑，当前方法都会被修改
- `开闭原则`：对扩展开放，对修改关闭
  当我们需要增加、减少某种支付方式(积分支付/组合支付)，或者增加优惠券等功能时，不可避免的要修改该段代码

特别是当 `if-else` 块中的代码量比较大时，后续的扩展和维护会变得非常复杂且容易出错。在阿里《Java开发手册》中，有这样的规则：`超过3层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现`。

策略模式是解决过多 `if-else`（或者 `switch-case`） 代码块的方法之一，提高代码的可维护性、可扩展性和可读性。下面我将从策略的定义、创建和使用这三个方面以上述网购支付为示例来分别进行说明。

## 1. 策略的定义

**策略接口的定义**，通常包含两个方法：获取策略类型的方法和处理策略业务逻辑的方法。

```text
/**
 * 第三方支付
 */
public interface Payment {

    /**
     * 获取支付方式
     * 
     * @return 响应，支付方式
     */
    PayTypeEnum getPayType();

    /**
     * 支付调用
     * 
     * @param order 订单信息
     * @return 响应，支付结果
     */
    PayResult pay(Order order);

}
```

**策略接口的实现**，每种支付类都实现了上述接口（基于接口而非实现编程），这样我们可以灵活的替换不同的支付方式。下边示例代码展示了每种支付方式的实现：

```text
/**
 * 微信支付
 */
@Component
public class WxPayment implements Payment {

    @Override
    public PayTypeEnum getPayType() {
        return PayTypeEnum.WX;
    }

    @Override
    public PayResult pay(Order order) {
        调用微信支付
        if (成功) {
            return PayResult.SUCCESS;
        } else {
            return PayResult.FAIL;
        }
    }

}
/**
 * 支付宝支付
 */
@Component
public class AlipayPayment implements Payment {

    @Override
    public PayTypeEnum getPayType() {
        return PayTypeEnum.ALIPAY;
    }

    @Override
    public PayResult pay(Order order) {
        调用支付宝支付
        if (成功) {
            return PayResult.SUCCESS;
        } else {
            return PayResult.FAIL;
        }
    }

}
/**
 * 银行卡支付
 */
@Component
public class BankCardPayment implements Payment {

    @Override
    public PayTypeEnum getPayType() {
        return PayTypeEnum.BANK_CARD;
    }

    @Override
    public PayResult pay(Order order) {
        调用银行卡支付
        if (成功) {
            return PayResult.SUCCESS;
        } else {
            return PayResult.FAIL;
        }
    }

}
```

## 2. 策略的创建

策略模式包含一组同类的策略，在使用时我们通常通过类型来判断创建哪种策略来进行使用。我们可以使用工厂模式来创建策略，以屏蔽策略的创建细节。如下代码所示：

```text
public class PaymentFactory {
    private static final Map<PayTypeEnum, Payment> payStrategies = new HashMap<>();

    static {
        payStrategies.put(PayTypeEnum.WX, new WxPayment());
        payStrategies.put(PayTypeEnum.ALIPAY, new AlipayPayment());
        payStrategies.put(PayTypeEnum.BANK_CARD, new BankCardPayment());
    }

    public static Payment getPayment(PayTypeEnum payType) {
        if (payType == null) {
            throw new IllegalArgumentException("pay type is empty.");
        }
        if (!payStrategies.containsKey(payType)) {
            throw new IllegalArgumentException("pay type not supported.");
        }
        return payStrategies.get(payType);
    }

}
```

或者使用 `Spring` 创建：

```text
@Component
public class PaymentFactory implements InitializingBean, ApplicationContextAware {
    private static final Map<PayTypeEnum, Payment> payStrategies = new HashMap<>();

    private ApplicationContext appContext;

    public static Payment getPayment(PayTypeEnum payType) {
        if (payType == null) {
            throw new IllegalArgumentException("pay type is empty.");
        }
        if (!payStrategies.containsKey(payType)) {
            throw new IllegalArgumentException("pay type not supported.");
        }
        return payStrategies.get(payType);
    }

    @Override
    public void setApplicationContext(@NonNull ApplicationContext applicationContext) {
        appContext = applicationContext;
    }

    @Override
    public void afterPropertiesSet() {
        // 将 Spring 容器中所有的 Payment 接口实现类注册到 payStrategies
        appContext.getBeansOfType(Payment.class)
                  .values()
                  .forEach(payment -> payStrategies.put(payment.getPayType(), payment));
    }
}
```

注意：以上两种创建方式，都是无状态的，即不包含成员变量，它们可以被共享使用。如果策略类是有状态的，需要根据业务场景每次创建新的策略对象，那么我们可以在工厂方法中，每次生成新的策略对象，而不是使用已经提前缓存好的策略对象。如下代码所示：

```text
public class PaymentFactory {
    public static Payment getPayment(PayTypeEnum payType) {
        if (payType == null) {
            throw new IllegalArgumentException("pay type is empty.");
        }
        if (payType == PayTypeEnum.WX) {
            return new WxPayment();
        }
        if (payType == PayTypeEnum.ALIPAY) {
            return new AlipayPayment();
        }
        if (payType == PayTypeEnum.BANK_CARD) {
            return new BankCardPayment();
        }
        throw new IllegalArgumentException("pay type not supported.");
    }

}
```

## 3. 策略的使用

通常我们事先并不知道会使用哪个策略，在程序运行时根据配置、用户输入、计算结果等来决定到底使用哪种策略。例如，前边支付方式的例子，我们会根据用户的选择来决定使用哪种支付方式。使用策略模式的代码实现如下：

```text
Order order = 订单信息
PayResult payResult = PaymentFactory.getPayment(payType).pay(order);
if (payResult == PayResult.SUCCESS) {
    System.out.println("支付成功");
} else if (payType == 支付宝) {
    System.out.println("支付失败");
}
```

综上代码中，接口类只负责业务策略的定义，每个策略的具体实现单独放在实现类中，工厂类 Factory 只负责获取具体实现类，而具体调用代码则负责业务逻辑的编排。这些实现用到了面向接口而非实现编程，满足了职责单一、开闭原则，从而达到了功能上的高内聚低耦合、提高了可维护性、扩展性以及代码的可读性。

