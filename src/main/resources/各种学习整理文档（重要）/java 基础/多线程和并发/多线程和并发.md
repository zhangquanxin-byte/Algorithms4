# 												多线程和并发

## 1、java实现多线程的几种方式

### 1.1、继承 **Thread** **类**

Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。 启动线程的唯一方

法就是通过 Thread 类的 start()实例方法。 start()方法是一个 native 方法，它将启动一个新线

程，并执行 run()方法。 

```java
public class MyThread extends Thread {
    public void run() { 
        System.out.println("MyThread.run()"); 
    } 
}
MyThread myThread1 = new MyThread(); 
myThread1.start();
```



### 1.2、实现 Runnable 接口

如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个

Runnable 接口。 

```java
public class MyThread extends OtherClass implements Runnable { 
    public void run() { 
        System.out.println("MyThread.run()"); 
    } 
}

//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：
MyThread myThread = new MyThread(); 
Thread thread = new Thread(myThread); 
thread.start(); 

//事实上，当传入一个 Runnable target 参数给 Thread 后， Thread 的 run()方法就会调用 target.run() 
public void run() {
	if (target != null) {
    	target.run(); 
	}
}
```



### 1.3、ExecutorService、 Callable、 Future

​		有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行

Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务

返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程

了。 

```
//创建一个线程池
ExecutorService pool = Executors.newFixedThreadPool(taskSize); 
// 创建多个有返回值的任务
List<Future> list = new ArrayList<Future>(); 

for (int i = 0; i < taskSize; i++) {
	Callable c = new MyCallable(i + " "); 
	// 执行任务并获取 Future 对象 
	Future f = pool.submit(c); 
	list.add(f); 
}
// 关闭线程池 pool.shutdown(); 
// 获取所有并发任务的运行结果
for (Future f : list) {
// 从 Future 对象上获取任务的返回值，并输出到控制台
System.out.println("res： " + f.get().toString()); 
}
```



5、基于线程池的方式
线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销
毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。 
6、4 种线程池
Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而
只是一个执行线程的工具。真正的线程池接口是 ExecutorService。 
}





## 2、Synchronized方法锁、对象锁、类锁

synchronized，通常称之为”同步锁“，在修饰代码块的时候须要传入一个引用对象做为“锁”的对象。

   在修饰方法的时候，默认是当前对象做为锁的对象
   在修饰类时，默认是当前类的Class对象做为所的对象
   故存在着方法锁、对象锁、类锁 这样的概念



### 2.1、代码块:

```
private static final Object lock = new Object();

public RspJDMT009 FileUpload(ReqJDMT009 req) {
	 synchronized (lock) {
	 	sout();
	 }
}
```



### 2.2、对象锁:

方法1、

    public synchronized void doLongTimeTaskC() {
        System.out.println("name = " + Thread.currentThread().getName() + ", begain");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    
        System.out.println("name = " + Thread.currentThread().getName() + ", end");
    
    }
方法2、

```
public void doLongTimeTaskC() {
	synchronized(this){
        System.out.println("name = " + Thread.currentThread().getName() + ", begain");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
	}


}
```



### 2.3、类锁：synchronized修饰静态的方法或者代码块

因为一个class不论被实例化多少次，**其中的静态方法和静态变量在内存中都只有一份**。因此，一旦一个静态的方法被声明为synchronized。此类全部的实例对象在调用此方法，共用同一把锁，咱们称之为类锁。****

java类可能会有不少对象，可是只有一个Class(字节码)对象，也就是说类的不一样实例之间共享该类的Class对象。**Class对象其实也仅仅是1个java对象，只不过有点特殊而已。**
因为每一个java对象都有1个互斥锁，而类的静态方法是须要Class对象。**因此所谓的类锁，只不过是Class对象的锁而已。**
**获取类的Class对象的方法有好几种，最简单的是[类名.class]的方式**

方法1

```
public synchronized static void doLongTimeTaskA() {
        System.out.println("name = " + Thread.currentThread().getName() + ", begain");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("name = " + Thread.currentThread().getName() + ", end");
    }
}
```

方式2

```
public void doLongTimeTaskC() {
	synchronized(xxx.class){
        System.out.println("name = " + Thread.currentThread().getName() + ", begain");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
	}
}
```





## 3、线程池

线程池如何用、线程池的好处、线程池的启动策略

### 3.1、如何创建一个线程池：

Java中已经提供了创建线程池的一个类：Executor

#### **3.1.1、ThreadPoolExecutor**：

```
public ThreadPoolExecutor(int corePoolSize,  
                              int maximumPoolSize,  
                              long keepAliveTime,  
                              TimeUnit unit,  
                              BlockingQueue<Runnable> workQueue,  
                              ThreadFactory threadFactory,  
                              RejectedExecutionHandler handler)
```

这是其中最重要的一个构造方法，这个方法决定了创建出来的线程池的各种属性，下面依靠一张图来更好的理解线程池和这几个参数：

![](D:\java oracle\学习资料\各种学习整理文档（重要）\java 基础\多线程和并发\线程池executor.png)

```
corePoolSize（必需）：核心线程数。即池中一直保持存活的线程数，即使这些线程处于空闲。但是将allowCoreThreadTimeOut参数设置为true后，核心线程处于空闲一段时间以上，也会被回收。
maximumPoolSize（必需）：池中允许的最大线程数。当核心线程全部繁忙且任务队列打满之后，线程池会临时追加线程，直到总线程数达到maximumPoolSize这个上限。
keepAliveTime（必需）：线程空闲超时时间。当非核心线程处于空闲状态的时间超过这个时间后，该线程将被回收。将allowCoreThreadTimeOut参数设置为true后，核心线程也会被回收。
unit（必需）：keepAliveTime参数的时间单位。有：TimeUnit.DAYS（天）、TimeUnit.HOURS（小时）、TimeUnit.MINUTES（分钟）、TimeUnit.SECONDS（秒）、TimeUnit.MILLISECONDS（毫秒）、TimeUnit.MICROSECONDS（微秒）、TimeUnit.NANOSECONDS（纳秒）
workQueue（必需）：任务队列，采用阻塞队列实现。当核心线程全部繁忙时，后续由execute方法提交的Runnable将存放在任务队列中，等待被线程处理。
threadFactory（可选）：线程工厂。指定线程池创建线程的方式。
handler（可选）：拒绝策略。当线程池中线程数达到maximumPoolSize且workQueue打满时，后续提交的任务将被拒绝，handler可以指定用什么方式拒绝任务。
```



#### **3.1.2、线程池的工作流程：**

![](D:\java oracle\学习资料\各种学习整理文档（重要）\java 基础\多线程和并发\线程池任务创建线程顺序.png)

#### 3.1.3、任务队列

```
使用ThreadPoolExecutor需要指定一个实现了BlockingQueue接口的任务等待队列。在ThreadPoolExecutor线程池的API文档中，一共推荐了三种等待队列，它们是：SynchronousQueue、LinkedBlockingQueue和ArrayBlockingQueue；

SynchronousQueue：同步队列。这是一个内部没有任何容量的阻塞队列，任何一次插入操作的元素都要等待相对的删除/读取操作，否则进行插入操作的线程就要一直等待，反之亦然。
LinkedBlockingQueue：无界队列（严格来说并非无界，上限是Integer.MAX_VALUE），基于链表结构。使用无界队列后，当核心线程都繁忙时，后续任务可以无限加入队列，因此线程池中线程数不会超过核心线程数。这种队列可以提高线程池吞吐量，但代价是牺牲内存空间，甚至会导致内存溢出。另外，使用它时可以指定容量，这样它也就是一种有界队列了。
ArrayBlockingQueue：有界队列，基于数组实现。在线程池初始化时，指定队列的容量，后续无法再调整。这种有界队列有利于防止资源耗尽，但可能更难调整和控制。
另外，Java还提供了另外4种队列：

PriorityBlockingQueue：支持优先级排序的无界阻塞队列。存放在PriorityBlockingQueue中的元素必须实现Comparable接口，这样才能通过实现compareTo()方法进行排序。优先级最高的元素将始终排在队列的头部；PriorityBlockingQueue不会保证优先级一样的元素的排序，也不保证当前队列中除了优先级最高的元素以外的元素，随时处于正确排序的位置。
DelayQueue：延迟队列。基于二叉堆实现，同时具备：无界队列、阻塞队列、优先队列的特征。DelayQueue延迟队列中存放的对象，必须是实现Delayed接口的类对象。通过执行时延从队列中提取任务，时间没到任务取不出来。更多内容请见DelayQueue。
LinkedBlockingDeque：双端队列。基于链表实现，既可以从尾部插入/取出元素，还可以从头部插入元素/取出元素。
LinkedTransferQueue：由链表结构组成的无界阻塞队列。这个队列比较特别的时，采用一种预占模式，意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素。

```

#### 3.1.4、拒绝策略

线程池有一个重要的机制：拒绝策略。当线程池workQueue已满且无法再创建新线程池时，就要拒绝后续任务了。拒绝策略需要实现RejectedExecutionHandler接口，不过Executors框架已经为我们实现了4种拒绝策略：

AbortPolicy（默认）：丢弃任务并抛出RejectedExecutionException异常。
CallerRunsPolicy：直接运行这个任务的run方法，但并非是由线程池的线程处理，而是交由任务的调用线程处理。
DiscardPolicy：直接丢弃任务，不抛出任何异常。
DiscardOldestPolicy：将当前处于等待队列列头的等待任务强行取出，然后再试图将当前被拒绝的任务提交到线程池执行。



#### 3.1.5、线程池状态

线程池有5种状态：

```
volatile int runState;
// runState is stored in the high-order bits
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
```

#### 3.1.6、初始化&容量调整&关闭



#### 3.1.7、Executors封装线程池

另外，`Executors`封装好了4种常见的功能线程池

**1、FixedThreadPool**

固定容量线程池。其特点是最大线程数就是核心线程数，意味着线程池只能创建核心线程，`keepAliveTime`为0，即线程执行完任务立即回收。任务队列未指定容量，代表使用默认值`Integer.MAX_VALUE`。适用于需要控制并发线程的场景。



**2、 SingleThreadExecutor**

单线程线程池。特点是线程池中只有一个线程（核心线程），线程执行完任务立即回收，使用有界阻塞队列（容量未指定，使用默认值`Integer.MAX_VALUE`）



**3、 ScheduledThreadPool**

定时线程池。指定核心线程数量，普通线程数量无限，线程执行完任务立即回收，任务队列为延时阻塞队列。这是一个比较特别的线程池，适用于**执行定时或周期性的任务**。



**4、CachedThreadPool**

缓存线程池。没有核心线程，普通线程数量为`Integer.MAX_VALUE`（可以理解为无限），线程闲置60s后回收，任务队列使用`SynchronousQueue`这种无容量的同步队列。适用于**任务量大但耗时低**的场景。



#### 3.1.7、线程池代码示例

```
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class MyTest {
	public static void main(String[] args) {
		// 创建线程池
		ThreadPoolExecutor threadPool = new ThreadPoolExecutor(3, 5, 5, TimeUnit.SECONDS,
				new ArrayBlockingQueue<Runnable>(5));
		// 向线程池提交任务
		for (int i = 0; i < threadPool.getCorePoolSize(); i++) {
			threadPool.execute(new Runnable() {
				@Override
				public void run() {
					for (int x = 0; x < 2; x++) {
						System.out.println(Thread.currentThread().getName() + ":" + x);
						try {
							Thread.sleep(2000);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
				}
			});
		}

		// 关闭线程池
		threadPool.shutdown(); // 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程
		// threadPool.shutdownNow(); // 设置线程池的状态为STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，该方法要慎用，容易造成不可控的后果
	}
}
```



https://blog.csdn.net/mu_wind/article/details/113806680





三个好处。

第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系

统的稳定性，使用线程池可以进行统一的分配，调优和监控 





4、