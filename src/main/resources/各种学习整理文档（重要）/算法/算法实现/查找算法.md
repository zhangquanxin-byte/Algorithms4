#    					查找算法

## 1 、查找算法介绍 

在 java 中，我们常用的查找有四种: 

1) 顺序(线性)查找 

2) 二分查找/折半查找 

3) 插值查找 

4) 斐波那契查找 



## 2、 线性查找算法 

有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此名称【顺序查找】 

要求: 如果找到了，就提 

示找到，并给出下标值。 

代码实现： 

```
/**
* 这里我们实现的线性查找是找到一个满足条件的值，就返回 
* @param arr 
* @param value 
* @return 
*/ 
public static int seqSearch(int[] arr, int value) { 
// 线性查找是逐一比对，发现有相同值，就返回下标 
    for (int i = 0; i < arr.length; i++) { 
		if(arr[i] == value) {
			return i; 
    	} 
   }
   
   return -1;
}
```





## 3、 二分查找算法 

### 3.1、二分查找： 

请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下 

标，如果没有就提示"没有这个数"。



### 3.2、二分查找算法的思路

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\二分查找思路.PNG)





### 3.3、二分查找的代码 

说明：增加了找到所有的满足条件的元素下标: 

课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值 

都查找到，比如这里的 1000

#### 递归方式：

```
package com.algorithm;

import java.util.ArrayList;
import java.util.List;

public class BinarySearch {
    public static void main(String[] args) {

        int[] arr={1,8, 10, 89, 1000,1000,1000, 1000,1234};
        int i = binarySearchFindOne(arr, 0, arr.length-1, 1234);


        List<Integer> integers = binarySearchFindAll(arr, 0, arr.length - 1, 1000);

        System.out.println("i = " + integers);

    }

    /**
     * arr数组从小到大排列
     * @param arr
     * @param left
     * @param right
     * @param findVal
     */
    public static int binarySearchFindOne(int[] arr,int left,int right ,int findVal){
        if (left > right) {
            return -1;
        }

        int mid=(left+right)/2;
        int midVal=arr[mid];
        if (midVal>findVal){
           return binarySearchFindOne(arr,left,mid-1,findVal);
        } else if (midVal < findVal) {
           return binarySearchFindOne(arr,mid+1,right,findVal);
        }else {
            return mid;
        }
    }


    public static List<Integer> binarySearchFindAll(int[] arr,int left,int right ,int findVal){
        if (left > right) {
            return new ArrayList<Integer>();
        }

        int mid=(left+right)/2;
        int midVal=arr[mid];
        if (midVal>findVal){
            return binarySearchFindAll(arr,left,mid-1,findVal);
        } else if (midVal < findVal) {
            return binarySearchFindAll(arr,mid+1,right,findVal);
        }else {


            // * 1. 在找到 mid 索引值，不要马上返回
            // * 2. 向 mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合 ArrayList
            // * 3. 向 mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合 ArrayList
            // * 4. 将 Arraylist 返回

            List<Integer> resIndexlist = new ArrayList<Integer>();

            //向 mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合 ArrayList
            int temp = mid - 1;
            while (true) {
                if (temp < 0 || arr[temp] != findVal) {
                    break;
                }

                //否则，就 temp 放入到 resIndexlist
                resIndexlist.add(temp);
                temp -= 1;
                //temp 左移
            }

            resIndexlist.add(mid);

            //向 mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合 ArrayList
            temp = mid + 1;
            while (true) {
                if (temp > arr.length - 1 || arr[temp] != findVal) {//退出
                    break;
                }

                resIndexlist.add(temp);
                temp += 1;
            }
            return resIndexlist;
        }
    }
}
```



#### 非递归方式：

```
package com.algorithm.algorithm;

public class BinarySearch {
    public static void main(String[] args) {
        //测试
        int[] arr = {1,3, 8, 10, 11, 67, 100};
        System.out.println("下标：" + binarySearchNoRecursion(arr,2));
    }

    /**
     * 非递归二分查找方式查找目标值
     * @param arr 存放所有数据的数组
     * @param target 目标值
     * @return 目标值所在数组下标。没找到，返回-1
     */
    public static int binarySearchNoRecursion(int[] arr, int target) {
        int left=0; //左边界
        int right=arr.length; //右边界
        int mid;

        while (left <= right) {
            mid = (left+right)/2;

            if (arr[mid] == target) { //数组中点值为目标值
                return mid;
            } else if (arr[mid] > target) {  //数组中点值大于所寻找的值，目标值位于数组左边
                right=mid-1;
            }else { //数组中点值小于所寻找的值，目标值位于数组右边
                left=mid+1;
            }

        }

        return -1;

    }
}
```





## 4、插值查找算法

### 1) 插值查找原理介绍: 

插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。 



### 2) 将折半查找中的求 mid 

索引的公式 , low 表示左边索引 left, high 表示右边索引 right. 

key 就是前面我们讲的 findVal



### 3) 取mid值算法

```
int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/*插值索引*/ 
```

对应前面的代码公式： 

int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left]) 



### 4）插值查找应用案例： 

请对一个有序数组进行插值查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下 

标，如果没有就提示"没有这个数"。

```
package com.algorithm;

import java.util.List;

public class InsertValueSearch {
    public static void main(String[] args) {
        int[] arr={1,8, 10, 89, 1000,1000,1000, 1000,1234};
        int res = improveBinarySearch(arr, 0, arr.length - 1, 200);
        
        System.out.println("res = " + res);
    }

    /**
     * 数组从小到大
     * @param arr
     * @param left
     * @param right
     * @param findVal
     * @return
     */
    public static int improveBinarySearch(int[] arr, int left, int right, int findVal) {
        
        //注意：findVal < arr[0] 和 findVal > arr[arr.length - 1] 必须需要
        // 否则我们得到的 mid 可能越界
        if (left > right || findVal<arr[left] || findVal>arr[right]) {
            return -1;
        }

        //判断要找的值在arr[right]--arr[left]数组最大和最小值之间的占比。判断mid取在哪一点right-left之间的占比
        int mid=left+(right-left)*(findVal-arr[left])/(arr[right]-arr[left]);

        if (findVal > arr[mid]) {
            return improveBinarySearch(arr,mid+1,right,findVal);
        } else if (findVal < arr[mid]) {
            return improveBinarySearch(arr,left,mid-1,findVal);
        }else {
            return mid;
        }


    }

}
```



### 5）插值查找注意事项： 

1) 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快. 

2) 关键字分布不均匀的情况下，该方法不一定比折半查找要好





## 5、斐波那契(黄金分割法)

### 5.1、斐波那契(黄金分割法)查找基本介绍: 

1) 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位 

数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神 

奇的数字，会带来意向不大的效果。 



2) 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值 

0.618 



### 5.2、斐波那契(黄金分割法)原理: 

斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位 

于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\fibonacci原理.png)

**对** **F(k-1)-1** **的理解**： 

1) 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明： 

只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间

位置为 mid=low+F(k-1)-1 



2) 类似的，每一子段也可以用相同的方式分割 

3) 但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使 

得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置）， 

都赋为 n 位置的值即可。 

```
while(n>fib(k)-1) 

k++; 
```





### 5.3、斐波那契查找应用案例： 

请对一个**有序数组**进行斐波那契查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求 

出下标，如果没有就提示"没有这个数"。

```
package com.algorithm;

import java.util.Arrays;

public class FibonacciSearch {
    static int MAX_SIZE;

    public static void main(String[] args) {
        int [] arr = {1,8, 10, 89, 1000, 1234,1255,4852,4852,8952,9999};
        System.out.println("index=" + fibonacciSearch(arr, 1000));

    }

    /**
     * 获取指定长度的斐波那契数列
     *
     * @param maxSize 多少个斐波那契数字
     * @return 斐波那契数组
     */
    public static int[] fibonacci(int maxSize) {
        int[] fibonacci = new int[maxSize];

        fibonacci[0] = 1;
        fibonacci[1] = 1;

        for (int i = 2; i < maxSize; i++) {
            fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2];
        }

        return fibonacci;
    }


    public static int fibonacciSearch(int[] arr,int findVal) {
        //第一波：如果数组长度不为某个斐波那契数字-1.扩充数组到该数值
        int high=arr.length-1;

        int low=0;


        //获取一个斐波那契数组
        int[] fibonacci = fibonacci(10);
        int k=0;  //大于排序数组长度的最小斐波那契数字数组下标

        while (arr.length>(fibonacci[k]-1)){
            k++;
        }

        //将旧数组copy到新数组,高位用arr[high]填充
        int[] arrPlus = Arrays.copyOf(arr, fibonacci[k]);

        for (int i = arr.length; i <arrPlus.length ; i++) {
            arrPlus[i]=arr[high];
        }


        //用循环排序
        while (low <=high ) {
            int mid=low+fibonacci[k-1]-1;

            if (findVal < arrPlus[mid]) {

                //为什么 k--
                // 说明
                // 1. 全部元素 = 前面的元素 + 后边元素
                // 2. f[k] = f[k-1] + f[k-2]
                // 因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]

                high = mid - 1;
                k--;

            } else if (findVal > arrPlus[mid]) {
                //为什么是 k -=2
                // 说明 //1. 全部元素 = 前面的元素 + 后边元素
                // 2. f[k] = f[k-1] + f[k-2]
                // 3. 因为后面我们有 f[k-2] 所以可以继续拆分 f[k-2] = f[k-3] + f[k-4]
                // 4. 即在 f[k-2] 的前面进行查找 k -=2
                // 5. 即下次循环 mid = f[k - 1 - 2] - 1

                low = mid+1;
                k-=2;
            }else {
                if (mid<=high){
                    return mid;
                }else {
                    return high;
                }
            }

        }

        //没找打
        return -1;

    }
}
```