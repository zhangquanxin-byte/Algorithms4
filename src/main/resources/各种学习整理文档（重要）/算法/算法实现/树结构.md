# 													树结构

## 1、树结构的基础部分

### 1.1、树结构优点

**数组存储方式的分析：**

优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。

缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 

**链式存储方式的分析**：

优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。

缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 

**树存储方式的分析**：

能提高数据存储，读取的效率,  比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。【示意图,后面详讲】案例: [7, 3, 10, 1, 5, 9, 12]



### 1.2、 树示意图

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\树示意图.png)



树的常用术语(结合示意图理解): 

1) 节点 

2) 根节点 

3) 父节点 

4) 子节点 

5) 叶子节点 (没有子节点的节点) 

6) 节点的权(节点值) 

7) 路径(从 root 节点找到该节点的路线) 

8) 层 

9) 子树 

10) 树的高度(最大层数) 

11) 森林 :多颗子树构成森林



### 1.3、 二叉树的概念

1) 树有很多种，每个节点**最多只能有两个子节点**的一种形式称为二叉树。 

2) 二叉树的子节点分为左节点和右节点 

3) 示意图

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\二叉树示意图.png)

4) 如果该二叉树的所有**叶子节点**都在**最后一层**，并且结点总数= **2^n -1** , n 为层数，则我们称为满二叉树。

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\满二叉树.png)



5) 如果该二叉树的所有**叶子节点**都在**最后一层**或者**倒数第二层**，而且最后一层的叶子节点在左边连续，倒数第二 

层的叶子节点在右边连续，我们称为完全二叉树

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\完全二叉树.png)





### 1.4、 二叉树遍历的说明 

使用**前序，中序和后序**对下面的二叉树进行遍历. 

1) **前序遍历**: 先输出父节点，再遍历左子树和右子树 

2) **中序遍历**: 先遍历左子树，再输出父节点，再遍历右子树

3) **后序遍历**: 先遍历左子树，再遍历右子树，最后输出父节点 



小结：看输出父节点的顺序，就确定是前序，中序还是后序 



### 1.5、 二叉树遍历应用实例(前序,中序,后序) 

应用实例的说明和思路 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\二叉树前中后遍历步骤.png)





### 1.6、 二叉树-查找指定节点 

要求 

1) 请编写前序查找，中序查找和后序查找的方法。 

2) 并分别使用三种查找方式，查找 heroNO = 5 的节点 

3) 并分析各种查找方式，分别比较了多少次 

4) 思路分析图解

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\二叉树查找思路.png)



1.7、代码实现

```
package com.algorithm.binaryTree;

public class BinaryTreeDemo {
    public static void main(String[] args) {
        HeroNode rootNode = new HeroNode(1, "宋江");
        BinaryTree tree = new BinaryTree(rootNode);

        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        HeroNode node5 = new HeroNode(5, "关胜");
        HeroNode node6 = new HeroNode(6, "霹雳火");
        HeroNode node7 = new HeroNode(7, "呼延灼");

        rootNode.setLeft(node2);
        rootNode.setRight(node3);
        node3.setLeft(node5);
        node3.setRight(node4);
        node5.setLeft(node6);
        node5.setRight(node7);

        //前序遍历
        //tree.preOrder();

        //中序遍历
        //tree.infixOrder();

        //后序遍历
        //tree.postOrder();

        //前序查找
      /*  HeroNode heroNode = tree.proSearch(1);
        if (heroNode != null) {
            System.out.printf("查询的编号=%d,名称=%s",heroNode.getNo(),heroNode.getName());
        }else {
            System.out.printf("没找到该编号角色");
        }*/


        //中序查找
     /*   HeroNode heroNode = tree.infixSearch(5);
        if (heroNode != null) {
            System.out.printf("查询的编号=%d,名称=%s",heroNode.getNo(),heroNode.getName());
        }else {
            System.out.printf("没找到该编号角色");
        }*/



        //后序查找
        HeroNode heroNode = tree.postSearch(5);
        if (heroNode != null) {
            System.out.printf("查询的编号=%d,名称=%s",heroNode.getNo(),heroNode.getName());
        }else {
            System.out.printf("没找到该编号角色");
        }

    }



}

class BinaryTree{
    private HeroNode root;

    public BinaryTree(HeroNode root) {
        this.root = root;
    }

    /**
     * 前序遍历
     */
    public void preOrder() {
        if (this.root != null) {
            this.root.proOrder();
        }else {
            System.out.println("二叉树为空！");
        }
    }

    /**
     * 中序遍历
     */
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        }else {
            System.out.println("二叉树为空！");
        }
    }

    /**
     * 后序遍历
     */
    public void postOrder() {
        if (this.root != null) {
            this.root.postOrder();
        }else {
            System.out.println("二叉树为空！");
        }
    }


    /**
     * 前序查找
     * @param no  查找的英雄编号
     * @return
     */
    public HeroNode proSearch(int no) {
        if (this.root != null) {
            return this.root.proSearch(no);
        } else {
            System.out.println("二叉树为空！");
            return null;
        }

    }

    /**
     * 中序查找
     * @param no  查找的英雄编号
     * @return
     */
    public HeroNode infixSearch(int no) {
        if (this.root != null) {
            return this.root.infixSearch(no);
        } else {
            System.out.println("二叉树为空！");
            return null;
        }

    }


    /**
     * 后序查找
     * @param no  查找的英雄编号
     * @return
     */
    public HeroNode postSearch(int no) {
        if (this.root != null) {
            return this.root.postSearch(no);
        } else {
            System.out.println("二叉树为空！");
            return null;
        }

    }










}



class HeroNode{
    private int no; //编号
    private String name; //名称
    private HeroNode left; //左节点
    private HeroNode right; //右节点


    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name=" + name +
                '}';
    }


    /**
     * 前序遍历
     */
    public void proOrder() {
        System.out.println(this);//先输出父结点

        //递归向左子树前序遍历
        if (this.left != null) {
            this.left.proOrder();
        }

        //递归向右子树前序遍历
        if (this.right != null) {
            this.right.proOrder();
        }

    }

    /**
     * 中序遍历
     */
    public void infixOrder() {
        //递归向左子树前序遍历
        if (this.left != null) {
            this.left.infixOrder();
        }

        //输出父结点
        System.out.println(this);

        //递归向右子树前序遍历
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    /**
     * 后续遍历
     */
    public void postOrder() {
        //递归向左子树前序遍历
        if (this.left != null) {
            this.left.postOrder();
        }

        //递归向右子树前序遍历
        if (this.right != null) {
            this.right.postOrder();
        }

        //输出父结点
        System.out.println(this);
    }

    /**
     * 前序查找
     */
    public HeroNode proSearch(int no) {
        System.out.println("前序查询比较~~~~");
        //比较当前结点是不是
        if (this.no==no) return this;

        HeroNode heroNode=null;

        //1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找
        // 2.如果左递归前序查找，找到结点，则返回
        if (this.left != null) {
            heroNode=this.left.proSearch(no);
        }

        if (heroNode != null) {//说明我们左子树找到
            return heroNode;
        }

        //1.左递归前序查找，找到结点，则返回，否继续判断，
        //2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找
        if (this.right != null) {
            heroNode = this.right.proSearch(no);
        }

        return heroNode;


    }

    /**
     * 中序查找
     */
    public HeroNode infixSearch(int no) {

        HeroNode heroNode=null;

        //判断当前结点的左子节点是否为空，如果不为空，则递归中序查找
        if (this.left != null) {
            heroNode=this.left.infixSearch(no);
        }

        if (heroNode != null) {
            return heroNode;
        }

        System.out.println("中序查询比较~~~~");
        //如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点
        if (this.no==no) return this;

        //否则继续进行右递归的中序查找
        if (this.right != null) {
            heroNode = this.right.infixSearch(no);
        }

        return heroNode;


    }


    /**
     * 后序查找
     */
    public HeroNode postSearch(int no) {

        HeroNode heroNode=null;

        //判断当前结点的左子节点是否为空，如果不为空，则递归后序查找
        if (this.left != null) {
            heroNode=this.left.proSearch(no);
        }

        //如果左续查找已经找到，退出
        if (heroNode != null) {
            return heroNode;
        }

        //如果左子树没有找到，则向右子树递归进行后序遍历查找
        if (this.right != null) {
            heroNode = this.right.proSearch(no);
        }

        System.out.println("后序查询比较~~~~");
        //如果右序查找已经找打，退出
        if (heroNode != null) {
            return heroNode;
        }

        //如果左右子树都没有找到，就比较当前结点是不是
        if (this.no==no) return this;

        return heroNode;
    }




}

```

### 1.7 二叉树-删除节点 

要求 

1) 如果删除的节点是叶子节点，则删除该节点 

2) 如果删除的节点是非叶子节点，则删除该子树.

3) 测试，删除掉 5 号叶子节点 和 3 号子树. 

4) 完成删除思路分析 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\删除二叉树结点思路分析.png)

```
binaryTree类方法

/**
 * 删除节点
 * @param no
 */
public void delNode(int no) {
    if (this.root == null) {
        System.out.println("该树为空树！");
    }else if (this.root.getNo() == no) {
        this.root=null;
    }else {
        this.root.delNode(no);
    }


}


HeroNode方法
 public void delNode(int no) {
 //思路 /** 
 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断 当前这个结点是不是需要删除结点.
 2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将 this.left = null; 并且就返回 (结束递归删除)
 3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将 this.right= null ;并且就返回 (结束递归删除)
 4. 如果第 2 和第 3 步没有删除结点，那么我们就需要向左子树进行递归删除 
 5. 如果第 4 步也没有删除结点，则应当向右子树进行递归删除
 
        if (this.left != null && this.left.no == no) {
            this.left=null;
        }

        if (this.right != null && this.right.no == no) {
            this.right=null;
        }

        if (this.left != null) {
            this.left.delNode(no);
        }

        if (this.right != null) {
            this.right.delNode(no);
        }
        
    }


```









## 2、 顺序存储二叉树 

### 2.1、 顺序存储二叉树的概念

基本说明 

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即**数组可以转换成树**，**树也可以转换成数组**， 

看右面的示意图

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\顺序存储二叉树.png)

### 2.2、顺序存储二叉树的特点: 

1) 顺序二叉树通常只考虑完全二叉树 

2) 第 n 个元素的左子节点为 2 * n + 1 

3) 第 n 个元素的右子节点为 2 * n + 2 

4) 第 n 个元素的父节点为 (n-1) / 2 

5) n : 表示二叉树中的第几个元素(按 0 开始编号如图所示)



### 2.3、顺序存储二叉树遍历

需求: 给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 

前序遍历的结果应当为 1,2,4,5,3,6,7 

代码：

```
package com.algorithm;

public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5, 6, 7 }; //创建一个 ArrBinaryTree
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
        //arrBinaryTree.preOrder(); // 1,2,4,5,3,6,7

        //arrBinaryTree.infixOrder(); // 4 2 5 1 6 3 7

        arrBinaryTree.postOrder(); // 4 5 2 6 7 3 1
    }


}

class ArrBinaryTree {
    private int[] arr;//

    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }

    public void preOrder() {
        preOrder(0);
    }

    public void infixOrder() {
        infixOrder(0);
    }

    public void postOrder() {
        postOrder(0);
    }



    /**
     * 前序遍历
     * @param index
     */
    public void preOrder(int index) {
        //如果数组为空，或者 arr.length = 0
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }

        //输出当前这个元素
        System.out.println(arr[index]);

        //向左递归遍历
        if (2 * index + 1 < arr.length) {
            preOrder(2*index+1);
        }

        //向右递归遍历
        if (2 * index + 2 < arr.length) {
            preOrder(2*index+2);
        }

    }

    /**
     * 中序遍历
     * @param index
     */
    public void infixOrder(int index) {
        //如果数组为空，或者 arr.length = 0
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }
        //向左递归遍历
        if (2 * index + 1 < arr.length) {
            infixOrder(2*index+1);
        }

        //输出当前这个元素
        System.out.println(arr[index]);

        //向右递归遍历
        if (2 * index + 2 < arr.length) {
            infixOrder(2*index+2);
        }

    }


    public void postOrder(int index) {
        //如果数组为空，或者 arr.length = 0
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }

        //向左递归遍历
        if (2 * index + 1 < arr.length) {
            postOrder(2*index+1);
        }

        //向右递归遍历
        if (2 * index + 2 < arr.length) {
            postOrder(2*index+2);
        }

        //输出当前这个元素
        System.out.println(arr[index]);
    }

}
```







## 3 、线索化二叉树 

### 3.1 、先看一个问题 

将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. n+1=7

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\线索化二叉树.png)

问题分析: 

1) 当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 14, 6} 

2) 但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上. 

3) 如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? 

4) 解决方案-**线索二叉**树





### 3.2 、线索二叉树基本介绍

1) n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向 

该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"） 

2) 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质 的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 

3) 一个结点的前一个结点，称为**前驱**结点 

4) 一个结点的后一个结点，称为后继结点



### 3.3、 线索二叉树应用案例 

应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\线索化二叉树.png)

**思路分析**：中序遍历的结果：{8, 3, 10, 1, 14, 6}

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\线索化二叉树示意图.png)

说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况: 

1) left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的 就是前驱节点. 

2) right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向 

的是后继节点.



代码实现：

```
package com.algorithm.ThreadedBinaryTree;

public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
        HeroNode root = new HeroNode(1, "tom");
        HeroNode node2 = new HeroNode(3, "jack");
        HeroNode node3 = new HeroNode(6, "smith");
        HeroNode node4 = new HeroNode(8, "mary");
        HeroNode node5 = new HeroNode(10, "king");
        HeroNode node6 = new HeroNode(14, "dim");

        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        ThreadedBinaryTree tree = new ThreadedBinaryTree(root);
        //中序线索化二叉树
        //tree.threadedMIdTree();

        //前序线索化二叉树
        //tree.threadedProTree();

        //后续线索化二叉树
        tree.threadedPostTree();

        HeroNode leftNode = node5.getLeft();
        HeroNode rightNode = node5.getRight();
        System.out.println("10 号结点的前驱结点是 =" + leftNode.getNo());
        System.out.println("10 号结点的后继结点是="+ rightNode.getNo());


        tree.threadedPostlist();
        //tree.threadedProlist();
    }
}


class ThreadedBinaryTree{

    public HeroNode root;

    public HeroNode pro;

    public ThreadedBinaryTree(HeroNode root) {
        this.root = root;
    }

    public void threadedMIdTree() {
        threadedMIdTree(this.root);
    }

    public void threadedProTree() {
        threadedProTree(this.root);
    }

    public void threadedPostTree() {
        threadedPostTree(this.root);
    }

    /**
     * 前序遍历二叉树
     */
    public void threadedProlist() {
        //定义一个变量，存储当前遍历的结点，从 root 开始
        HeroNode node=this.root;

        while (node != null) {
            //输出当前节点
            System.out.println("node = " + node);


            //循环的找到 leftType == 1 的结点，第一个找到就是 8 结点
            // 后面随着遍历而变化,因为当 leftType==1 时，说明该结点是按照线索化
            // 处理后的有效结点
            while (node.getLeftType()== 0) {
                node=node.getLeft();
                System.out.println("node = " + node);
            }

            //如果当前结点的右指针指向的是后继结点,就一直输出
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }

            //替换这个遍历的结点
            node=node.getRight();
        }
    }


    /**
     * 中序遍历二叉树
     */
    public void threadedMidlist() {
        //定义一个变量，存储当前遍历的结点，从 root 开始
        HeroNode node=this.root;

        while (node != null) {

            //循环的找到 leftType == 1 的结点，第一个找到就是 8 结点
            // 后面随着遍历而变化,因为当 leftType==1 时，说明该结点是按照线索化
            // 处理后的有效结点
            while (node.getLeftType()== 0) {
                node=node.getLeft();
            }

            System.out.println("node = " + node);

            //如果当前结点的右指针指向的是后继结点,就一直输出
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }

            //替换这个遍历的结点
            node=node.getRight();
        }
    }

   /* *//**
     * 后序遍历二叉树
     *//*
    public void threadedPostlist() {
        //定义一个变量，存储当前遍历的结点，从 root 开始
        HeroNode node=this.root;

        while (node != null) {


            //循环的找到 leftType == 1 的结点，第一个找到就是 8 结点
            // 后面随着遍历而变化,因为当 leftType==1 时，说明该结点是按照线索化
            // 处理后的有效结点
            while (node.getLeftType()== 0) {
                node=node.getLeft();
            }

            System.out.println("node = " + node);

            //如果当前结点的右指针指向的是后继结点,就一直输出
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }

            System.out.println("node = " + node);

            //替换这个遍历的结点
            node=root.getRight();
        }
    }*/



    /**
     * 前序线索化二叉树
     * @param node 从哪个节点开始开始线索化
     */
    private void threadedProTree(HeroNode node) {
        //如果是空节点， 无法线索化
        if (node==null) {
            return;
        }


        //线索化当前节点
        //处理当前结点的前驱结点
        if (node.getLeft() == null) {
            node.setLeft(this.pro);
            node.setLeftType(1);  //设置当前左节点为前驱节点
        }
        //处理后继结点
        //在当前节点处可以设置前一节点后驱节点为当前节点   无法设置当前节点的后驱节点
        if (pro != null && pro.getRight() == null) {
            pro.setRight(node);
            pro.setRightType(1);  //设置前一节点的后驱节点为当前节点
        }

        //!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点
        this.pro=node;

        //线索化左子树
        //如果已经线索化过。无需再次线索化
        if (node.getLeftType() != 1) {
            threadedProTree(node.getLeft());
        }

        //线索化右子树
        //如果该右节点已经线索化，无需再次线索化
        if (node.getRightType() != 1) {
            threadedProTree(node.getRight());
        }

    }


    /**
     * 中序线索化二叉树
     * @param node 从哪个节点开始开始线索化
     */
    private void threadedMIdTree(HeroNode node) {
        //如果是空节点， 无法线索化
        if (node == null) {
            return;
        }

        //线索化左子树
        threadedMIdTree(node.getLeft());

        //线索化当前节点
        //处理当前结点的前驱结点
        if (node.getLeft() == null) {
            node.setLeft(this.pro);
            node.setLeftType(1);  //设置当前左节点为前驱节点
        }
        //处理后继结点
        //在当前节点处可以设置前一节点后驱节点为当前节点   无法设置当前节点的后驱节点
        if (pro != null && pro.getRight() == null) {
            pro.setRight(node);
            pro.setRightType(1);  //设置前一节点的后驱节点为当前节点
        }

        //!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点
        this.pro=node;


        //线索化右子树
        threadedMIdTree(node.getRight());

    }


    /**
     * 后续序线索化二叉树
     * @param node 从哪个节点开始开始线索化
     */
    private void threadedPostTree(HeroNode node) {
        //如果是空节点， 无法线索化
        if (node == null) {
            return;
        }

        //线索化左子树
        threadedPostTree(node.getLeft());

        //线索化右子树
        threadedPostTree(node.getRight());

        //线索化当前节点
        //处理当前结点的前驱结点
        if (node.getLeft() == null) {
            node.setLeft(this.pro);
            node.setLeftType(1);  //设置当前左节点为前驱节点
        }
        //处理后继结点
        //在当前节点处可以设置前一节点后驱节点为当前节点   无法设置当前节点的后驱节点
        if (pro != null && pro.getRight() == null) {
            pro.setRight(node);
            pro.setRightType(1);  //设置前一节点的后驱节点为当前节点
        }

        //!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点
        this.pro=node;



    }


}

class HeroNode{
    private int no;

    private String name;

    private HeroNode left;

    private HeroNode right;

    private int leftType;

    private int rightType;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
}
```



### 3.4、 遍历线索化二叉树 

1) 说明：对前面的中序线索化的二叉树， 进行遍历 

2) 分析：因为线索化后，**各个结点指向有变化，因此原来的遍历方式不能使用**，这时需要使用新的方式遍历 

线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 

遍历的次 序应当和中序遍历保持一致。



已实现前序遍历和中序遍历。后续遍历暂未实现。代码如上





## 4、树的实际应用

### 4.1 、堆排序：

1) 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 

杂度均为 **O(nlogn)**，它也是不稳定排序。 

2) 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 

注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。 

3) 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 

4) 大顶堆举例说明

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\大顶推介绍.png)

5) 小顶堆举例说明 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\小顶堆介绍.png)



6) 一般升序采用大顶堆，降序采用小顶堆

具体算法细节在排序算法.md文档中





### 4.2、赫夫曼树 

#### 4.2.1 基本介绍 

1) 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，**若该树的带权路径长度**(wpl)达到最小，称这样的二叉树为 最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。 

2) 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近 



#### 4.2.2 赫夫曼树几个重要概念和举例说明 

1) **路径和路径长度**：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通**路**

**中分支的数目称为路径长度**。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1 

2) **结点的权及带权路径长度**：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。**结** 

**点的带权路径长度为**：从根结点到该结点之间的路径长度与该结点的权的乘积 

3) 树的带权路径长度：树的带权路径长度规定为**所有叶子结点的带权路径长度之和**，记为 WPL(weighted path 

length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。 

4) WPL 最小的就是赫夫曼树

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\赫夫曼树.png)



#### 4.2.3 赫夫曼树创建思路图解 

给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树. 

思路分析(示意图)： 

{13, 7, 8, 3, 29, 6, 1} 

**构成赫夫曼树的步骤**： 

1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 

2) 取出根节点权值最小的两颗二叉树 

3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和尚硅谷 Java 数据结构和算法 

4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数 

据都被处理，就得到一颗赫夫曼树 

5) 图解:

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\生产赫夫曼树第一步.png)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\生产赫夫曼树第二步.png)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\生产赫夫曼树第三步.png)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\生成赫夫曼树第四步.png)

#### 4.2.4 赫夫曼树的代码实现 

```
package com.algorithm.huffmanTree;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

public class HuffmanTreeDemo {
    public static void main(String[] args) {
        int arr[] = { 13, 7, 8, 3, 29, 6, 1 };
        Node root = creatHuffmanTree(arr);
        preOrder(root);
    }

    //编写一个前序遍历的方法
    private static void preOrder(Node node) {
        if (node != null) {
            node.preOrder();
        }else {
            System.out.println("空树无法遍历！");
        }
    }


    /**
     * 创建赫夫曼树
     * @param arr 需要创建成哈夫曼树的数组
     * @return 创建好后的赫夫曼树的 root 结点
     */
    public static Node creatHuffmanTree(int[] arr) {

        // 第一步为了操作方便
        // 1. 遍历 arr 数组
        // 2. 将 arr 的每个元素构成成一个 Node
        ArrayList<Node> nodes = new ArrayList<>();

        //将数组变为node节点放入集合
        for (int i : arr) {
            nodes.add(new Node(i));
        }

        while (nodes.size() > 1) {
            Collections.sort(nodes);

            Node leftNode = nodes.get(0);  //左节点
            Node rightNode = nodes.get(1); //右节点

            //根据最小的两个子节点构造一个新父节点的二叉树,并以当前数组最小的两个值为左右节点
            Node parentNode = new Node(leftNode.getValue() + rightNode.getValue());
            parentNode.setLeftNode(leftNode);
            parentNode.setRightNode(rightNode);

            //将子节点移除，新的父节点放入
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parentNode);

        }

        return nodes.get(0);


    }
}

class Node implements Comparable<Node>{
    private int value;  //节点值

    private Node leftNode; //左节点

    private Node rightNode; //右节点

    public Node(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public Node getLeftNode() {
        return leftNode;
    }

    public void setLeftNode(Node leftNode) {
        this.leftNode = leftNode;
    }

    public Node getRightNode() {
        return rightNode;
    }

    public void setRightNode(Node rightNode) {
        this.rightNode = rightNode;
    }

    @Override
    public int compareTo(Node o) {
        return this.value-o.getValue();
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    public void preOrder() {

        System.out.println(this);

        //遍历左子树
        if (this.getLeftNode() != null) {
            this.getLeftNode().preOrder();
        }

        //遍历右子树
        if (this.getRightNode() != null) {
            this.getRightNode().preOrder();
        }
    }
}
```





### 4.3、赫夫曼编码

#### 4.3.1 基本介绍 

1) 赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法 

2) 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 

3) 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间 

4) 赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码 



#### 4.3.2 原理剖析 

通信领域中信息的处理方式 1-定长编码 

举例：

i like like like java do you like a java       // 共40个字符(包括空格)  
105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97  //对应Ascii码

01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 //对应的二进制
按照二进制来传递信息，总的长度是  359   (包括空格)
在线转码 工具 ：https://www.mokuge.com/tool/asciito16/ 



通信领域中信息的处理方式 2-变长编码

举例：

i like like like java do you like a java       // 共40个字符(包括空格)

d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数
0=  ,  1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.

按照上面给各个字符规定的编码，则我们在传输  "i like like like java do you like a java" 数据时，编码就是 10010110100...  

字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码



通信领域中信息的处理方式 3-赫夫曼编码

步骤如下; 

传输的 字符串 

1) i like like like java do you like a java 

2) d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9 // 各个字符对应的个数 

3) 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 



#### 4.3.3、赫夫曼编码步骤 

构成赫夫曼树的步骤： 

1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 

2) 取出根节点权值最小的两颗二叉树 

3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 

4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理， 就得到一颗赫夫曼树

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\赫夫曼编码.png)

5) 根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ， 编码 

如下: o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 : 01 

6) 按照上面的赫夫曼编码，我们的"i like like like java do you like a java" 字符串对应的编码为 (注 意这里我们使用的无损压缩) 10101001101111011110100110111101111010011011110111101000011000011100110011110000110 

01111000100100100110111101111011100100001100001110 通过赫夫曼编码处理 长度为 133 

7） 长度为 ： 133 

说明: 

原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%

此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性，赫夫曼编码是无损处理方案 



**注意事项** 

注意, 这个赫夫曼树根据**排序方法不同**，也可能不太一样，这样对应的**赫夫曼编码也不完全一样**，但是 **wpl** 是 

一样的，都是最小的, 最后生成的赫夫曼编码的长度是一样，比如: 

如果我们让每次生成的新的二叉树总是排在权 

值相同的二叉树的最后一个，则生成的二叉树为

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\第二种赫夫曼编码.png)





#### 4.3.4、最佳实践-数据压缩

##### 4.3.4.1、创建赫夫曼树

将给出的一段文本，比如 "i like like like java do you like a java" ， 根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理 ，形式如 "1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110
" 

步骤1：根据赫夫曼编码压缩数据的原理，需要创建 "i like like like java do you like a java" 对应的赫夫曼树.

思路：前面已经分析过了，而且我们已然讲过了构建赫夫曼树的具体实现。
代码实现：



##### 4.3.4.2、生成赫夫曼编码和赫夫曼编码后的数据

1) 生成赫夫曼树对应的赫夫曼编码 , 如下表: 

=01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011 

2) 使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码，将"i like like like java do you like a java" 

字符串生成对应的编码数据, 形式如下. 

10101000101111111100100010111111110010001011111111001001010011011100011100000110111010001111001010 00101111111100110001001010011011100 

3) 思路：前面已经分析过了，而且我们讲过了生成赫夫曼编码的具体实现。



4.3.4 最佳实践-文件压缩 



4.3.4.1具体要求： 

给你一个图片文件，要求对其进行无损压缩, 

看看压缩效果如何。 

1) 思路：读取文件-> 得到赫夫曼编码表 -> 完成压缩 

2) 代码实现

```
/**
     * 压缩文件：二进制文件（音视频），文本文件
     * @param srdFile
     * @param dstFile
     */
    public static void zipFile(String srdFile, String dstFile) {
        FileInputStream fileInputStream=null;
        FileOutputStream fileOutputStream=null;
        ObjectOutputStream oos=null;
        byte[] bytes;

        try {
            //创建文件的输入流
            fileInputStream = new FileInputStream(srdFile);
            //创建一个和源文件大小一样的 byte[]
            bytes=new byte[fileInputStream.available()];
            //读取文件
            fileInputStream.read(bytes);
            //直接对源文件压缩
            byte[] zipCode = huffmanZip(bytes);

            //创建文件的输出流, 存放压缩文件
            fileOutputStream= new FileOutputStream(dstFile);
            //创建一个和文件输出流关联的 ObjectOutputStream
            oos = new ObjectOutputStream(fileOutputStream);
            //把 赫夫曼编码后的字节数组写入压缩文件
            oos.writeObject(zipCode);
            //这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用
            oos.writeObject(huffmanCodes);
            //注意一定要把赫夫曼编码 写入压缩文件
            System.out.println("压缩成功！");

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (oos != null) {
                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            if (fileOutputStream != null) {
                try {
                    fileOutputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            if (fileInputStream != null) {
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }


    }
```

4.3.4.2 最佳实践-文件解压(文件恢复) 

具体要求：将前面压缩的文件，重新恢复成原来的文件。 

1) 思路：读取压缩文件(数据和赫夫曼编码表)-> 完成解压(文件恢复) 

2) 代码实现： 

```
/**
 * 解压缩huffman编码压缩的文件
 * @param zipFile  压缩文件路径
 * @param dstFile 解压文件路径
 */
public static void unZipFile(String zipFile, String dstFile) {
    InputStream is =null;
    ObjectInputStream ois=null;

    OutputStream os=null;

    try {
        //创建文件输入流
        is =new FileInputStream(zipFile);
        //创建一个和 is 关联的对象输入流
        ois=new ObjectInputStream(is);
        //读取 byte 数组 huffmanBytes
        byte[] zipCode=(byte[])ois.readObject();
        //读取赫夫曼编码表
        Map<Byte,String> huffmancode = (Map<Byte,String>)ois.readObject();
        //解码
        byte[] decode = decode(huffmancode, zipCode);
        //将 bytes 数组写入到目标文件
        os=new FileOutputStream(dstFile);

        os.write(decode);

    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }finally {

    }


}
```



#### 4.4、所有霍夫曼压缩解压缩代码汇总

```
package com.algorithm.huffmanCode;

import java.io.*;
import java.util.*;

public class HuffmanCode {
    public static void main(String[] args) {
        /*String words="i like like like java do you like a ijkoop1234uiipp";
        ArrayList<Node> nodes = getNodes(words.getBytes());

        Node huffmanRootNode = getHuffmanRootNode(nodes);

        getCode(huffmanRootNode,"",new StringBuilder(""));

        //将每个字符和出现的次数组成节点，并放入集合
        for (Map.Entry<Byte, String> o : huffmanCodes.entrySet()) {
            System.out.println("key="+o.getKey()+"  value="+o.getValue());
        }

        //byte[] zip = zip(words.getBytes(), huffmanCodes);

        byte[] zip = huffmanZip(words.getBytes());

        System.out.println("Arrays.toString(wordsg) = " + Arrays.toString(words.getBytes()));
        System.out.println("Arrays.toString(zip) = " + Arrays.toString(zip));

        byte[] decode = decode(huffmanCodes, zip);

        System.out.println("Arrays.toString(decode) = " + Arrays.toString(decode));
        System.out.println(new String(decode));*/

        //测试压缩文件
        String srcFile="D:\\ttt\\5.txt";
        String dstFile="D:\\ttt\\5.zip";
        zipFile(srcFile, dstFile);

        //测试解压缩文件
         String srcFile1="D:\\ttt\\5.zip";
        String dstFile1="D:\\ttt\\51.txt";
        unZipFile(srcFile1, dstFile1);
    }


    /**
     * 把指定数组根据霍夫曼编码压缩
     * @param bytes
     * @return
     */
    public static byte[] huffmanZip(byte[] bytes){


        ArrayList<Node> nodes = getNodes(bytes);

        System.out.println(nodes.size());

        Node huffmanRootNode = getHuffmanRootNode(nodes);

        getCode(huffmanRootNode,"",new StringBuilder(""));

        //将每个字符和出现的次数组成节点，并放入集合
        for (Map.Entry<Byte, String> o : huffmanCodes.entrySet()) {
            System.out.println("key="+o.getKey()+"  value="+o.getValue());
        }

        byte[] zip = zip(bytes, huffmanCodes);

        return zip;

    }


    /**
     * 获得需要传输的字符节点的集合
     * @param bytes 需要传输的字符数组
     * @return  每个字符对应的树节点
     */
    public static ArrayList<Node> getNodes(byte[] bytes) {
        ArrayList<Node> nodeList= new ArrayList<>();

        Map<Byte,Integer> nodes=new HashMap<>();

        //遍历获得每个字符出现的次数
        if (bytes != null) {
            for (byte aByte : bytes) {
                if (nodes.get(aByte) != null) {
                    nodes.put(aByte, nodes.get(aByte)+1);
                }else {
                    nodes.put(aByte,1);
                }
            }
        }

        //将每个字符和出现的次数组成节点，并放入集合
        for (Map.Entry<Byte, Integer> o : nodes.entrySet()) {
            nodeList.add(new Node(o.getKey(),o.getValue()));
        }


        return nodeList;
    }


    /**
     * 根据节点集合获得霍夫曼树
     * @param nodeList 节点集合
     * @return
     */
    public static Node getHuffmanRootNode(List<Node> nodeList) {
        if (nodeList == null) {
            throw new RuntimeException("组成霍夫曼树的集合为空！");
        }

        while (nodeList.size() > 1) {
            Collections.sort(nodeList);

            Node node0 = nodeList.get(0);

            Node node1 = nodeList.get(1);

            Node parentNode = new Node(null, node0.getNum() + node1.getNum());

            parentNode.setLeftNode(node0);
            parentNode.setRightNode(node1);

            nodeList.add(parentNode);
            nodeList.remove(node0);
            nodeList.remove(node1);
        }

        return nodeList.get(0);


    }

    //生成赫夫曼树对应的赫夫曼编码
    // 思路:
    // 1. 将赫夫曼编码表存放在 Map<Byte,String> 形式
    // 生 成 的 赫 夫 曼 编 码 表 {32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011}
    static Map<Byte, String> huffmanCodes = new HashMap<Byte,String>();

    //2. 在生成赫夫曼编码表时，需要去拼接路径, 定义一个 StringBuilder 存储某个叶子结点的路径
    static StringBuilder stringBuilder = new StringBuilder();

    /**
     * 生成赫夫曼树每个字符对应的赫夫曼编码
     * @param node 节点
     * @param code  0表示左递归  1表示右递归
     * @param builder
     */
    public static void getCode(Node node,String code, StringBuilder builder) {
        StringBuilder stringBuilder2 = new StringBuilder(builder);
        stringBuilder2.append(code);
        if (node != null) {
            if (node.getValue() == null) {  //表示该节点是非叶子节点
                //向左递归
                getCode(node.getLeftNode(),"0",stringBuilder2);
                //向右递归
                getCode(node.getRightNode(),"1",stringBuilder2);

            }else {
                huffmanCodes.put(node.getValue(),stringBuilder2.toString());
            }
        }

    }


    /**
     * 通过字符编码表  将每个字节替换为字符编码表对应为二进制码，达到压缩的目的
     * @param bytes 待压缩的字节数组
     * @param huffmanCodes 字符编码表
     */
    public static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes ) {
        StringBuilder builder = new StringBuilder();

        //将原本的八位字节数组编为我们自定义的二进制表示
        for (byte aByte : bytes) {
            builder.append(huffmanCodes.get(aByte));
        }

        //数组长度
        int len;
        if (builder.length() % 8 == 0) {
            len=builder.length()/8;

        }else {
            len=builder.length()/8+1;
        }


        //将我们自定义的二进制字符串转换为字节数组 ,多一个字节用来标识最后一个字符占几位
        byte[] zipByte = new byte[len+1];

        //
        int index=0;

        StringBuilder subStr = new StringBuilder();

        int lastBtLen=0; //记录最后一个字节的长度

        for (int i = 0; i <builder.length() ; i+=8) {

            subStr.delete(0,subStr.length());
            if (i+8<builder.length()){
                subStr = subStr.append(builder.substring(i, i + 8));
            }else {
                subStr = subStr.append(builder.substring(i));

                lastBtLen=subStr.length();

                System.out.println("最后一个字符："+subStr+";  长度："+lastBtLen);
                //前面补0
                while (subStr.length()<=8){
                    subStr.insert(0,"0");
                }
            }

            zipByte[index]=(byte) Integer.parseInt(subStr.toString(),2);
            index++;
        }

        //最后加一个字节来标识倒数第二个字符占几位
        zipByte[index]=(byte) lastBtLen;


        return zipByte;

    }


    /**
     * 将字节转换为字符串
     * @param flag 如果不是最后二个字节就为true，最后倒数第二字节为false
     * @param b 传入的字节
     * @return 字符串
     */
    public static String byteToString(boolean flag ,byte b,byte lastByte) {

        int temp=b;

        //对正数补0
        if (flag) {
            temp|=256;
        }else {
            temp|=256;
            int idx=lastByte;
        }

        String binaryString = Integer.toBinaryString(temp);

        //做了对正数补0的temp都大于256，所以需要截取
        if (flag) {
            return binaryString.substring(binaryString.length() - 8);
        } else {
            return binaryString.substring(binaryString.length() - lastByte);
        }

    }

    /**
     * 将huffman压缩过的字节码解压缩为正常的字节码
     * @param huffmanCodes  霍夫曼编码表
     * @param huffmanZipCode 用霍夫曼编码表压缩后的字节码
     * @return  返回解压后正常的字节码
     */
    public static byte[] decode(Map<Byte , String> huffmanCodes, byte[] huffmanZipCode) {
        StringBuilder builder = new StringBuilder();


        //把huffman字节转换为字符串
        for (int i = 0; i <huffmanZipCode.length-1 ; i++) {
            boolean flag=(i==huffmanZipCode.length-2);
            //把每个字节转为字符串
            builder.append(byteToString(!flag,huffmanZipCode[i],huffmanZipCode[huffmanZipCode.length-1]));
        }

        //System.out.println("builder = " + builder);

        //反转huffman编码表
        Map<String,Byte> map = new HashMap<>();
        for (Map.Entry<Byte, String> entry: huffmanCodes.entrySet()){
            map.put(entry.getValue(),entry.getKey());
        }


        //将得到的字节放到集合中,反向查询 a->100 100->a
        ArrayList<Byte> list= new ArrayList<>();
        int btLength=builder.length();
        for (int i = 0; i <btLength; ) {

            //内部遍历字符串,不断轮询匹配是否存在于编码表
            int count=1;
            boolean flag=true;
            Byte bt=null;

            while (flag){
                //超过数组长度，退出
                if((i + count)>btLength) break;

                String key = builder.substring(i, i + count); //i 不动，让 count 移动，指定匹配到一个字符
                if ((bt=map.get(key))!=null){
                    list.add(bt);
                    flag=false;
                }else {
                    count++;
                }
            }

            i=i+count;
        }

        byte[] oglByte=new byte[list.size()];
        for (int i = 0; i <list.size() ; i++) {
/*            System.out.println("oglByte["+i+"] = " + oglByte[i]);
            System.out.println("list["+i+"] = " + list.get(i));*/
            oglByte[i]=list.get(i);
        }

        return oglByte;
    }




    /**
     * 压缩文件：二进制文件（音视频），文本文件
     * @param srdFile
     * @param dstFile
     */
    public static void zipFile(String srdFile, String dstFile) {
        FileInputStream fileInputStream=null;
        FileOutputStream fileOutputStream=null;
        ObjectOutputStream oos=null;
        byte[] bytes;

        try {
            //创建文件的输入流
            fileInputStream = new FileInputStream(srdFile);
            //创建一个和源文件大小一样的 byte[]
            bytes=new byte[fileInputStream.available()];
            //读取文件
            fileInputStream.read(bytes);
            //直接对源文件压缩
            byte[] zipCode = huffmanZip(bytes);

            //创建文件的输出流, 存放压缩文件
            fileOutputStream= new FileOutputStream(dstFile);
            //创建一个和文件输出流关联的 ObjectOutputStream
            oos = new ObjectOutputStream(fileOutputStream);
            //把 赫夫曼编码后的字节数组写入压缩文件
            oos.writeObject(zipCode);
            //这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用
            oos.writeObject(huffmanCodes);
            //注意一定要把赫夫曼编码 写入压缩文件
            System.out.println("压缩成功！");

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (oos != null) {
                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            if (fileOutputStream != null) {
                try {
                    fileOutputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            if (fileInputStream != null) {
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }


    }


    /**
     * 解压缩huffman编码压缩的文件
     * @param zipFile  压缩文件路径
     * @param dstFile 解压文件路径
     */
    public static void unZipFile(String zipFile, String dstFile) {
        InputStream is =null;
        ObjectInputStream ois=null;

        OutputStream os=null;

        try {
            //创建文件输入流
            is =new FileInputStream(zipFile);
            //创建一个和 is 关联的对象输入流
            ois=new ObjectInputStream(is);
            //读取 byte 数组 huffmanBytes
            byte[] zipCode=(byte[])ois.readObject();
            //读取赫夫曼编码表
            Map<Byte,String> huffmancode = (Map<Byte,String>)ois.readObject();
            //解码
            byte[] decode = decode(huffmancode, zipCode);
            //将 bytes 数组写入到目标文件
            os=new FileOutputStream(dstFile);

            os.write(decode);

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }finally {

        }


    }

}


class Node implements Comparable<Node> {
    private Byte value;// 字符

    private int num; //出现次数

    private Node leftNode; //左节点

    private  Node rightNode; //右节点

    public Node(Byte value, int num) {
        this.value = value;
        this.num = num;
    }

    public Byte getValue() {
        return value;
    }

    public void setValue(Byte value) {
        this.value = value;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public Node getLeftNode() {
        return leftNode;
    }

    public void setLeftNode(Node leftNode) {
        this.leftNode = leftNode;
    }

    public Node getRightNode() {
        return rightNode;
    }

    public void setRightNode(Node rightNode) {
        this.rightNode = rightNode;
    }

    @Override
    public int compareTo(Node o) {
        return this.getNum()-o.getNum();
    }
}
```



### 4.4、二叉排序树



#### 4.4.1、二叉排序树作用

高效的完成对数据的查询和添加

数组 ：

数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢. [示意图] 

数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位 

置后，后面的数据需整体移动，速度慢。[示意图] 



链式存储-链表 ：

不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动



#### 4.4.2、二叉排序树介绍

**二叉排序树**：BST: (Binary Sort(Search) Tree), 对于二叉排序树的**任何一个非叶子节点**，要求**左子节点的值比当** 

**前节点的值小**，**右子节点的值比当前节点的值大**。 

**特别说明**：如果有相同的值，可以将该节点放在左子节点或右子节点 

比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\二叉排序树插入数据.png)





#### 4.4.3、 二叉排序树创建和遍历 

一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 

Array(7, 3, 10, 12, 5, 1, 9) ， 创 

建成对应的二叉排序树为 : 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\二叉排序树.png)

```
int[] arr = {7, 3, 10, 12, 5, 1, 9, 2};

BinarySortTree tree = new BinarySortTree();

Arrays.stream(arr).forEach(value -> tree.addNode(new Node(value)));


/**
 * 二叉排序树新增节点
 *
 * @param node 需要新增的节点
 */
public void addNode(Node node) {
    if (node == null) {
        return;
    } else {
        //新增节点值小于当前节点
        if (this.value > node.value) {
            if (this.left == null) {
                this.left = node;
                return;
            } else {
                this.left.addNode(node);
            }
        } else {
            if (this.right == null) {
                this.right = node;
                return;
            } else {
                this.right.addNode(node);
            }
        }

    }
}
```





#### 4.4.4 二叉排序树的删除 

二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 

1) **删除叶子节点** (比如：2, 5, 9, 12) 

2) 删除**只有一颗子树的节点** (比如：1) 

3) 删除**有两颗子树的节点**. (比如：7, 3，10 ) 

4) 操作的思路分析

```
//对删除结点的各种情况的思路分析: 
第一种情况: 删除叶子节点 (比如：2, 5, 9, 12) 
思路
(1) 需求先去找到要删除的结点 targetNode
(2) 找到 targetNode 的 父结点 parent 
(3) 确定 targetNode 是 parent 的左子结点 还是右子结点 
(4) 根据前面的情况来对应删除 左子结点 parent.left = null 右子结点 parent.right = null; 

第二种情况: 删除只有一颗子树的节点 比如 1 
思路
(1) 需求先去找到要删除的结点 targetNode 
(2) 找到 targetNode 的 父结点 parent 
(3) 确定 targetNode 的子结点是左子结点还是右子结点 
(4) targetNode 是 parent 的左子结点还是右子结点 
(5) 如果 targetNode 有左子结点 
	5. 1 如果 targetNode 是 parent 的左子结点parent.left = targetNode.left; 
	5.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.left; 
(6) 如果 targetNode 有右子结点 
	6.1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.right;
    6.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right
    
情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 ) 
思路
(1) 需求先去找到要删除的结点 targetNode 
(2) 找到 targetNode 的 父结点 parent 
(3) 从 targetNode 的右子树找到最小的结点 
(4) 用一个临时变量，将 最小结点的值保存 temp = 11 
(5) 删除该最小结点 
(6) targetNode.value = temp    
    
    
```



#### 4.4.5 完整代码实现：

```
package com.algorithm.binarySortTreeDemo;

import java.util.Arrays;

public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9, 2};

        BinarySortTree tree = new BinarySortTree();
        Arrays.stream(arr).forEach(value -> tree.addNode(new Node(value)));

        System.out.println("删除节点前。。。。。。");
        tree.infixSearch();

        System.out.println("删除节点后。。。。。。");
        tree.delNode(1);
        //tree.infixSearch();


        tree.delNode(3);
        tree.delNode(7);
        tree.delNode(2);
        tree.delNode(10);
        tree.delNode(12);
        tree.delNode(9);
        tree.delNode(5);
        System.out.println("删除节点后。。。。。。");
        tree.infixSearch();

 /*       tree.delNode(9);
        System.out.println("删除节点9后。。。。。。");
        tree.infixSearch();*/

    }


}


class BinarySortTree {

    Node root; //根节点

    public void addNode(Node node) {
        if (this.root == null) {
            this.root = node;
        } else {
            root.addNode(node);
        }
    }

    /**
     * 中序遍历
     */
    public void infixSearch() {
        if (this.root == null) {
            System.out.println("空二叉排序树，无法遍历");
        } else {
            this.root.infixSearch();
        }
    }

    /**
     * 查找需要删除的节点
     *
     * @param value 需要删除的节点的值
     * @return 需要删除的节点
     */
    public Node findNode(int value) {
        if (this.root == null) {
            return null;
        } else {
            return this.root.nodeSearch(value);
        }
    }

    /**
     * 查找需要删除的节点的父节点
     *
     * @param value 需要删除的节点的值
     * @return 删除的节点的父节点
     */
    public Node findParentNode(int value) {
        if (this.root == null) {
            return null;
        } else {
            return this.root.findParentNode(value);
        }
    }

    public void delNode(int value) {
        if (this.root == null) {
            System.out.println("当前二叉排序树为空，无法删除节点！");
            return;
        } else {
            //查找需要删除的节点
            Node delNode = findNode(value);
            if (delNode == null) {
                System.out.println("当前二叉排序树找不到要删除的节点值:"+value+"！");
                return;
            }

            //待删除的节点的父节点  如果父节点为空，需要删除的节点为根节点
            Node parentNode = findParentNode(value);
           // System.out.println("parentNode.value = " + parentNode.value);

            //待删除的节点的值区分为：叶子结点，
            if (delNode.left == null && delNode.right == null) {
                if (parentNode == null) {
                    this.root = null;
                } else if (parentNode.left != null && parentNode.left.value == value) {
                    parentNode.left = null;
                } else if (parentNode.right != null && parentNode.right.value == value) {
                    parentNode.right = null;
                }
            } else if (delNode.left != null && delNode.right != null) { //待删除的节点有左右子节点
                //待删除的节点delNode有左、右节点
                //方案一：待删除节点的右子树查询最小值节点，并删除。返回最小值，将最小值赋值给待删除节点delNode。
                /*Node rightMinNode = delNode.delRightMinNode();
                delNode.value=rightMinNode.value;*/

                //方案二：待删除节点的左子树查询最大值节点，并删除。返回该最大值，将最大值赋值给待删除节点delNode。
                Node leftMaxNode = delNode.delLeftMaxNode();
                delNode.value=leftMaxNode.value;
            }else {  //待删除的节点只有一个节点：左、右子节点

                //如果父节点为空，待删除节点为根节点
                if (parentNode == null) {
                    if (delNode.left!=null){
                        this.root=delNode.left;
                    }else {
                        this.root=delNode.right;
                    }
                }else {
                    if (delNode.left != null) {   //如果待删除节点存在左子节点
                        if (parentNode.left.value == delNode.value) { //待删除节点为父节点的左子节点
                            parentNode.left=delNode.left;
                        }else if (parentNode.right.value == delNode.value){ //待删除节点为父节点的右子节点
                            parentNode.right=delNode.left;
                        }
                    }else if (delNode.right != null){  //如果待删除节点存在右子节点
                        if (parentNode.left.value == delNode.value) {  //待删除节点为父节点的左子节点
                            parentNode.left=delNode.right;
                        }else if (parentNode.right.value == delNode.value){ //待删除节点为父节点的右子节点
                            parentNode.right=delNode.right;
                        }
                    }

                }



            }

        }


    }


}


class Node {

    int value;

    Node left;

    Node right;

    public Node(int value) {
        this.value = value;
    }

    /**
     * 二叉排序树新增节点
     *
     * @param node 需要新增的节点
     */
    public void addNode(Node node) {
        if (node == null) {
            return;
        } else {
            //新增节点值小于当前节点
            if (this.value > node.value) {
                if (this.left == null) {
                    this.left = node;
                    return;
                } else {
                    this.left.addNode(node);
                }
            } else {
                if (this.right == null) {
                    this.right = node;
                    return;
                } else {
                    this.right.addNode(node);
                }
            }

        }
    }


    /**
     * 查询需要删除的节点
     *
     * @param value 节点值
     * @return 删除的节点
     */
    public Node nodeSearch(int value) {
        if (this.value == value) {
            return this;
        } else {
            if (this.left != null && this.value > value) {
                return this.left.nodeSearch(value);
            } else if (this.right != null && this.value <= value) {
                return this.right.nodeSearch(value);
            } else {
                return null;
            }
        }

    }


    /**
     * 寻找需要删除的节点的父节点
     *
     * @param value 需要删除的节点值。如果有需要可以改成node
     * @return 删除节点的父节点
     */
    public Node findParentNode(int value) {

        //如果当前节点为父节点
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {
            if (this.left != null && this.value>value) {  //如果左节点不为空同时当前节点的值大于查询的节点的值。向左遍历
                return this.left.findParentNode(value);
            } else if (this.right != null && this.value<=value) {
                return this.right.findParentNode(value); //如果右节点不为空同时当前节点的值小于等于查询的节点的值。向右遍历
            } else {
                return null;
            }
        }
    }


    /**
     * 删除当前节点的右子树的最小值
     * @return 已经删除的最小节点
     */
    public Node delRightMinNode() {
        if (this.right == null) {
            return null;
        } else {
            //待返回的最小节点值
            Node minNode = this.right;

            Node parentNodeOfMinNode=this;

            //由于二叉树小的node放左边，循环查找最左边的值
            while (minNode.left != null) {
                parentNodeOfMinNode=minNode;
                minNode = minNode.left;
            }


            //待删除的最小节点左边的叶子节点
            if (parentNodeOfMinNode != this) {
                parentNodeOfMinNode.left=null;
            }else {//如果有待删除的最小节点是this.right节点。也即意味着this.right没有左子节点
                parentNodeOfMinNode.right=minNode.right;
            }


            return minNode;
        }


    }


    /**
     * 删除当前节点的左子树的最大值
     * @return 已经删除的最大节点
     */
    public Node delLeftMaxNode() {
        if (this.left == null) {
            return null;
        } else {
            //待返回的最大节点值
            Node maxNode = this.left;

            Node parentNodeOfMinNode=this;

            //由于二叉树大的node放右边，循环查找最右边的值
            while (maxNode.right != null) {
                parentNodeOfMinNode=maxNode;
                maxNode = maxNode.right;
            }

            //如果有待删除的最大节点是this.right节点。也即意味着this.left没有右子节点
            if (parentNodeOfMinNode == this) {
                parentNodeOfMinNode.left=maxNode.left;
            }else { //待删除的最小节点为必然为叶子节点，只需要让该节点的父节点的右节点==null即可删除该节点
                parentNodeOfMinNode.right=null;
            }


            return maxNode;
        }


    }


    /**
     * 中序遍历二叉排序树
     */
    public void infixSearch() {

        if (this.left != null) {
            this.left.infixSearch();
        }

        System.out.println("节点值：" + this.value);

        if (this.right != null) {
            this.right.infixSearch();
        }
    }
}
```







### 4.5、平衡二叉树(AVL 树) 

#### 4.5.1 看一个案例(说明二叉排序树可能的问题) 

给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在. 

左边 BST 存在的问题分析: 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\二叉排序树的极端情况.png)



1) 左子树全部为空，从形式上看，更像一个单链表. 

2) 插入速度没有影响 

3) 查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比 

单链表还慢 

4) 解决方案-平衡二叉树(AVL)



#### 4.5.2、基本介绍 

1) 平衡二叉树也叫平衡**二叉搜索树**（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。 

2) 具有以下特点：它是**一 棵空树**或**它的左右两个子树的高度差的绝对值不超过** **1**，并且**左右两个子树都是一棵** 

**平衡二叉树**。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 

3) 举例说明, 看看下面哪些 AVL 树, 为什么?

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\AVL树举例.png)



#### 4.5.3 应用案例-单旋转(左旋转) 

1) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8} 

2) 思路分析(示意图)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\AVL左旋思路.png)



代码实现

```java
//左旋转方法 
private void leftRotate() { 

    //创建新的结点，以当前根结点的值 
    Node newNode = new Node(value); 

    //把新的结点的左子树设置成当前结点的左子树 

    newNode.left = left; 

    //把新的结点的右子树设置成带你过去结点的右子树的左子树 

    newNode.right = right.left; 

    //把当前结点的值替换成右子结点的值 

    value = right.value; 

    //把当前结点的右子树设置成当前结点右子树的右子树 

    right = right.right; 

    //把当前结点的左子树(左子结点)设置成新的结点 

    left = newNode;

}
```



#### 4.5.4 应用案例-单旋转(右旋转) 

1) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6} 

2) 思路分析(示意图) 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\AVL右旋思路分析.png)



代码实现//右旋转

```java
private void rightRotate() { 

    Node newNode = new Node(value); 

    newNode.right = right; 

    newNode.left = left.right; 

    value = left.value; 

    left = left.left; 

    right = newNode;
}
```



#### 4.5.5、应用案例-双旋转 

​	前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转 

不能完成平衡二叉树的转换。比如数列 

int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树. 

int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL 树 

1) ![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\AVL双旋转分析后.png)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\AVL双旋转正确过程.png)

2) 解决思路分析 

1. 当符号右旋转的条件时 
2. 如果它的左子树的右子树高度大于它的左子树的高度
3. 先对当前这个结点的左节点进行左旋转 
4. 在对当前结点进行右旋转的操作即可 

```
public void addNode(Node node) {
    if (node == null) {
        return;
    } else {
        //新增节点值小于当前节点
        if (this.value > node.value) {
            if (this.left == null) {
                this.left = node;
                return;
            } else {
                this.left.addNode(node);
            }
        } else {
            if (this.right == null) {
                this.right = node;
                return;
            } else {
                this.right.addNode(node);
            }
        }

    }


    //当添加完一个结点后，如果: (右子树的高度-左子树的高度) > 1 , 左旋转
    if (rightHeight()>leftHeight()){
        //如果右子树的左子树的高度大于右子树的右子树的高度，需要先将当前节点的右子树右旋.再将当前节点左旋
        if (right!=null && right.leftHeight()>right.rightHeight()){
            right.rightRotate();
        }else{ //否则直接左旋
            leftRotate();
        }

        return;
    }

    //当添加完一个结点后，如果: 右子树的高度<左子树的高度 , 右旋转
    if (rightHeight() < leftHeight()) {
        //如果左子树的左子树高度小于左子树的右子树的高度，需要先将当前节点的左子树左旋，然后再将当前节点右旋
        if (left != null && left.leftHeight() < left.rightHeight()) {
            left.leftRotate();
        } else {
            //直接将当前节点右旋即可
            rightRotate();
        }

        return;

    }
    
}
```

****

**记得新增、删除节点时都要做处理***







#### 4.5.6、完整代码：

```
package com.algorithm.AVLTree;

import java.util.Arrays;

public class AVLTreeDemo {
    public static void main(String[] args) {
        //int[] arr = {4,3,6,5,7,8};
        //int[] arr = { 10, 12, 8, 9, 7, 6 };
        int[] arr = { 10, 11, 7, 6, 8, 9 };
        AVLTree avlTree = new AVLTree();
        Arrays.stream(arr).forEach(t->avlTree.addNode(new Node(t)));

        //遍历
        System.out.println("中序遍历");
        avlTree.infixSearch();

        System.out.println("在平衡处理~~");
        System.out.println("树的高度=" + avlTree.getRoot().height());
        System.out.println("树的左子树高度=" + avlTree.getRoot().leftHeight());
        System.out.println("树的右子树高度=" + avlTree.getRoot().rightHeight());
        System.out.println("当前的根结点=" + avlTree.getRoot().value);//8

    }
}

class AVLTree{

    private Node root; //根节点

    public void addNode(Node node) {
        if (this.root == null) {
            this.root = node;
        } else {
            root.addNode(node);
        }
    }

    public Node getRoot() {
        return root;
    }

    /**
     * 中序遍历
     */
    public void infixSearch() {
        if (this.root == null) {
            System.out.println("空二叉排序树，无法遍历");
        } else {
            this.root.infixSearch();
        }
    }

    /**
     * 查找需要删除的节点
     *
     * @param value 需要删除的节点的值
     * @return 需要删除的节点
     */
    public Node findNode(int value) {
        if (this.root == null) {
            return null;
        } else {
            return this.root.nodeSearch(value);
        }
    }

    /**
     * 查找需要删除的节点的父节点
     *
     * @param value 需要删除的节点的值
     * @return 删除的节点的父节点
     */
    public Node findParentNode(int value) {
        if (this.root == null) {
            return null;
        } else {
            return this.root.findParentNode(value);
        }
    }

    public void delNode(int value) {
        if (this.root == null) {
            System.out.println("当前二叉排序树为空，无法删除节点！");
            return;
        } else {
            //查找需要删除的节点
            Node delNode = findNode(value);
            if (delNode == null) {
                System.out.println("当前二叉排序树找不到要删除的节点值:"+value+"！");
                return;
            }

            //待删除的节点的父节点  如果父节点为空，需要删除的节点为根节点
            Node parentNode = findParentNode(value);
            // System.out.println("parentNode.value = " + parentNode.value);

            //待删除的节点的值区分为：叶子结点，
            if (delNode.left == null && delNode.right == null) {
                if (parentNode == null) {
                    this.root = null;
                } else if (parentNode.left != null && parentNode.left.value == value) {
                    parentNode.left = null;
                } else if (parentNode.right != null && parentNode.right.value == value) {
                    parentNode.right = null;
                }
            } else if (delNode.left != null && delNode.right != null) { //待删除的节点有左右子节点
                //待删除的节点delNode有左、右节点
                //方案一：待删除节点的右子树查询最小值节点，并删除。返回最小值，将最小值赋值给待删除节点delNode。
                /*Node rightMinNode = delNode.delRightMinNode();
                delNode.value=rightMinNode.value;*/

                //方案二：待删除节点的左子树查询最大值节点，并删除。返回该最大值，将最大值赋值给待删除节点delNode。
                Node leftMaxNode = delNode.delLeftMaxNode();
                delNode.value=leftMaxNode.value;
            }else {  //待删除的节点只有一个节点：左、右子节点

                //如果父节点为空，待删除节点为根节点
                if (parentNode == null) {
                    if (delNode.left!=null){
                        this.root=delNode.left;
                    }else {
                        this.root=delNode.right;
                    }
                }else {
                    if (delNode.left != null) {   //如果待删除节点存在左子节点
                        if (parentNode.left.value == delNode.value) { //待删除节点为父节点的左子节点
                            parentNode.left=delNode.left;
                        }else if (parentNode.right.value == delNode.value){ //待删除节点为父节点的右子节点
                            parentNode.right=delNode.left;
                        }
                    }else if (delNode.right != null){  //如果待删除节点存在右子节点
                        if (parentNode.left.value == delNode.value) {  //待删除节点为父节点的左子节点
                            parentNode.left=delNode.right;
                        }else if (parentNode.right.value == delNode.value){ //待删除节点为父节点的右子节点
                            parentNode.right=delNode.right;
                        }
                    }

                }



            }

        }


    }




}


class Node {

    int value;

    Node left;

    Node right;

    public Node(int value) {
        this.value = value;
    }

    /**
     * 二叉排序树新增节点
     *
     * @param node 需要新增的节点
     */
    public void addNode(Node node) {
        if (node == null) {
            return;
        } else {
            //新增节点值小于当前节点
            if (this.value > node.value) {
                if (this.left == null) {
                    this.left = node;
                    return;
                } else {
                    this.left.addNode(node);
                }
            } else {
                if (this.right == null) {
                    this.right = node;
                    return;
                } else {
                    this.right.addNode(node);
                }
            }

        }


        //当添加完一个结点后，如果: (右子树的高度-左子树的高度) > 1 , 左旋转
        if (rightHeight()>leftHeight()){
            //如果右子树的左子树的高度大于右子树的右子树的高度，需要先将当前节点的右子树右旋.再将当前节点左旋
            if (right!=null && right.leftHeight()>right.rightHeight()){
                right.rightRotate();
            }else{ //否则直接左旋
                leftRotate();
            }

            return;
        }

        //当添加完一个结点后，如果: 右子树的高度<左子树的高度 , 右旋转
        if (rightHeight() < leftHeight()) {
            //如果左子树的左子树高度小于左子树的右子树的高度，需要先将当前节点的左子树左旋，然后再将当前节点右旋
            if (left != null && left.leftHeight() < left.rightHeight()) {
                left.leftRotate();
            } else {
                //直接将当前节点右旋即可
                rightRotate();
            }

            return;

        }





    }


    /**
     * 查询需要删除的节点
     *
     * @param value 节点值
     * @return 删除的节点
     */
    public Node nodeSearch(int value) {
        if (this.value == value) {
            return this;
        } else {
            if (this.left != null && this.value > value) {
                return this.left.nodeSearch(value);
            } else if (this.right != null && this.value <= value) {
                return this.right.nodeSearch(value);
            } else {
                return null;
            }
        }

    }


    /**
     * 寻找需要删除的节点的父节点
     *
     * @param value 需要删除的节点值。如果有需要可以改成node
     * @return 删除节点的父节点
     */
    public Node findParentNode(int value) {

        //如果当前节点为父节点
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {
            if (this.left != null && this.value>value) {  //如果左节点不为空同时当前节点的值大于查询的节点的值。向左遍历
                return this.left.findParentNode(value);
            } else if (this.right != null && this.value<=value) {
                return this.right.findParentNode(value); //如果右节点不为空同时当前节点的值小于等于查询的节点的值。向右遍历
            } else {
                return null;
            }
        }
    }


    /**
     * 删除当前节点的右子树的最小值
     * @return 已经删除的最小节点
     */
    public Node delRightMinNode() {
        if (this.right == null) {
            return null;
        } else {
            //待返回的最小节点值
            Node minNode = this.right;

            Node parentNodeOfMinNode=this;

            //由于二叉树小的node放左边，循环查找最左边的值
            while (minNode.left != null) {
                parentNodeOfMinNode=minNode;
                minNode = minNode.left;
            }


            //待删除的最小节点左边的叶子节点
            if (parentNodeOfMinNode != this) {
                parentNodeOfMinNode.left=null;
            }else {//如果有待删除的最小节点是this.right节点。也即意味着this.right没有左子节点
                parentNodeOfMinNode.right=minNode.right;
            }


            return minNode;
        }


    }


    /**
     * 删除当前节点的左子树的最大值
     * @return 已经删除的最大节点
     */
    public Node delLeftMaxNode() {
        if (this.left == null) {
            return null;
        } else {
            //待返回的最大节点值
            Node maxNode = this.left;

            Node parentNodeOfMinNode=this;

            //由于二叉树大的node放右边，循环查找最右边的值
            while (maxNode.right != null) {
                parentNodeOfMinNode=maxNode;
                maxNode = maxNode.right;
            }

            //如果有待删除的最大节点是this.right节点。也即意味着this.left没有右子节点
            if (parentNodeOfMinNode == this) {
                parentNodeOfMinNode.left=maxNode.left;
            }else { //待删除的最小节点为必然为叶子节点，只需要让该节点的父节点的右节点==null即可删除该节点
                parentNodeOfMinNode.right=null;
            }


            return maxNode;
        }


    }

    /**
     * 返回左子树的高度
     * @return
     */
    public int leftHeight() {
        if (left == null) {
            return 0;
        }else {
            return  left.height();
        }
    }

    /**
     * 返回右子树的高度
     * @return
     */
    public int rightHeight() {
        if (right == null) {
            return 0;
        }else {
            return  right.height();
        }
    }


    /**
     * 获得以当前节点为根节点的树的高度
     * @return
     */
    public int height() {
        return Math.max(left==null?0:left.height(),right==null?0:right.height())+1;
    }

    /**
     * 将当前节点左旋
     */
    public void leftRotate() {
        //new一个新节点，值为当前节点值
        Node newNode = new Node(value);

        //将新节点的左节点指向当前节点的左节点
        newNode.left=left;

        //将当前节点的右节点指向当前节点的右节点的左节点
        if (right == null) {
            throw new RuntimeException("当前节点的右节点为null,无法左旋！");
        }
        newNode.right=right.left;

        //修改当前节点的值为当前节点右节点的值
        value=right.value;

        //修改当前节点的左节点的为上面newNode新节点
        left=newNode;

        //修改当前节点的右节点为当前节点的右节点的右节点
        right=right.right;
    }


    /**
     *当前节点右旋
     */
    public void rightRotate() {
        //new一个新节点,值为当前节点的值
        Node newNode = new Node(value);

        //新节点的左节点只想当前节点的左节点的右节点
        if (left == null) {
            throw new RuntimeException("当前节点的左节点的值为null,无法右旋！");
        }
        newNode.left=left.right;

        //新节点的右节点指向当前节点的右节点
        newNode.right=right;

        //当前节点的值改为当前节点左节点的值
        value=left.value;

        //当前节点的左节点指向当前节点的左节点的右节点
        left=left.left;

        //当前节点的右节点指向新节点newNode
        right=newNode;
    }



    /**
     * 中序遍历二叉排序树
     */
    public void infixSearch() {

        if (this.left != null) {
            this.left.infixSearch();
        }

        System.out.println("节点值：" + this.value);

        if (this.right != null) {
            this.right.infixSearch();
        }
    }
}
```









### 4.6、多路查找树

#### 4.6.1、 二叉树的问题分析 

二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\二叉树存在的问题.png)

二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)， 就存在如下问题:
问题1：在构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响
问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度.



#### 4.6.2、多叉树 

1) 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点， 就是多叉树（multiway tree） 

2) 后面我们讲解的 2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。 

3) 举例说明(下面 2-3 树就是一颗多叉树)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\多叉树.png)





#### 4.6.3、B 树的基本介绍 

B 树通过重新组织节点，降低树的高度，并且减少 i/o 读写次数来提升效率。

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\B树.png)

**B树通过重新组织节点， 降低了树的高度.**

​		文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入

​		将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中



#### 4.6.4、2-3 树 

**2-3 树是最简单的 B 树结构**, 具有如下特点: 

1) 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) 

2) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点

3) 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点. 

4) 2-3 树是由二节点和三节点构成的树。



**2-3 树应用案例** 

将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序。(演示一下构建 2-3 树的过程.) 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\23树.png)

插入规则: 

1) 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) 

2) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点. 

3) 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点 

4) 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层， 拆后仍然需要满足上面 3 个条件。 

5) 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则



**其它说明：**

除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图:

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\234树.png)



#### 4.6.5、B 树、B+树和 B*树 

##### 4.6.5.1 B 树的介绍 

B-tree 树即 B 树，B 即 Balanced，平衡的意思。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树 

是一种树，而 B 树又是另一种树。实际上，B-tree 就是指的 B 树。 

12.3.2 B 树的介绍 

前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学 

习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图: 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\B树示例.png)

**B树的说明:**
1、B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4
2、B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点

3、关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.
4、搜索有可能在非叶子结点结束
5、其搜索性能等价于在关键字全集内做一次二分查找



##### 4.6.5.2 B+树的介绍 

B+树是 B 树的变体，也是一种多路搜索树。

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\B+树示例.png)

**B+树的说明:**
1、B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找
2、所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。
3、不可能在非叶子结点命中
4、非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
5、更适合文件索引系统
6、B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.





##### 4.6.5.2 B*树的介绍 

B*树是 B+树的变体，在 B+树的**非根和非叶子结点**再增**加指向兄弟的指针**。

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\B星树.png)



**B*树的说明:**1) 

1、B**树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为 2/3，而 B+树的块的最低使用率为的 

1/2。 

2、从第 1 个特点我们可以看出，B*树分配新结点的概率比 B+树要低，空间使用率更高