# 					栈实现加减乘除计算器									

后缀表达式适合计算机进行运算。在开发中，我们需要将中缀表达式转成后缀表达式。



## 1、思路：

**1）中缀表达式转后缀表达式**

**2）计算机计算后缀表达式**



## 2、具体步骤

### 2.1、后缀表达式的计算机求值

​        从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

```
例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

从左至右扫描，将3和4压入堆栈；
遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
将5入栈；
接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
将6入栈；
最后是-运算符，计算出35-6的值，即29，由此得出最终结果
```



### 2.2、中缀表达式转换为后缀表达式

具体步骤如下:
1、初始化两个栈：运算符栈s1和储存中间结果的栈s2；
2、从左至右扫描中缀表达式；
3、遇到操作数时，将其压s2；
4、遇到运算符时，比较其与s1栈顶运算符的优先级：
	4.1、如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
	4.2、否则，若优先级比栈顶运算符的高，也将运算符压入s1；
	4.3、否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；

5、遇到括号时：

​	(1) 如果是左括号“(”，则直接压入s1 

​	(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
6、重复步骤2至5，直到表达式的最右边
7、将s1中剩余的运算符依次弹出并压入s2
8、依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式



```
举例说明:
将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下
```

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\中缀表达式转后缀表达式过程.PNG)

```
因此结果为 
"1 2 3 + 4 × + 5 –"
```





3、核心代码：

```java
package com.algorithm;

import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class SimpleCalculator {
    public static void main(String[] args) {
        String infix = "(30 + 10 )*5-(6/3)";
        List<String> list = InfixConvertToSuffix(infix);
        System.out.println("list = " + list);
        int i = calculateSuffix(list);
        System.out.println("计算结果为 = " + i);


    }

    /**
     * 中缀表达式转为后缀表达式
     *
     * @param infixExpression 中缀表达式：字符串形式
     * @return 后缀表达式：List数组形式
     */
    public static List<String> InfixConvertToSuffix(String infixExpression) {
        //将中缀字符串转为List集合
        List<String> list = stringToList(infixExpression);
        System.out.println("list = " + list);

        //用来存放运算符和小括号的栈
        Stack<String> stack = new Stack<>();

        //用来存放后缀表达式结果的List
        List<String> result = new ArrayList<>();

        //中缀转后缀
        for (String item : list) {
            if (item.matches("\\d+")) {
                result.add(item);
            } else if ("(".equals(item)) {
                stack.push(item);
            } else if (")".equals(item)) {
                while (!stack.isEmpty() && !"(".equals(stack.peek())) {
                    result.add(stack.pop());
                }

                //把栈中的(左括号弹出
                if (stack.isEmpty()) throw new RuntimeException("表达式有误，左括号缺少");
                stack.pop();
            } else {

                /*if (stack.isEmpty() || stack.peek().equals("(") || getOperatePriority(item) > getOperatePriority(stack.peek()))
                    stack.push(item);
                else {

                    do {
                        result.add(stack.pop());
                    } while(!stack.isEmpty() && !stack.peek().equals("(") && getOperatePriority(item) <= getOperatePriority(stack.peek()));

                    stack.push(item);
                }*/

                while(stack.size() != 0 && !stack.peek().equals("(") && getOperatePriority(item) <= getOperatePriority(stack.peek())) {
                    result.add(stack.pop());
                }
                //还需要将 item 压入栈
                stack.push(item);

            }
        }

        //将栈中剩余的运算符依次弹出并压入List
        while (!stack.isEmpty()) {
            result.add(stack.pop());
        }

        return result;
    }

    public static int calculateSuffix(List<String> suffixExpression) {

        Stack<String> stack = new Stack<>();

        int result = 0;

        for (String item : suffixExpression) {
            if (item.matches("\\d++")) {
                stack.push(item);
            } else {
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());

                if (item.equals("*")) {
                    result = num1 * num2;
                } else if (item.equals("/")) {
                    result = num2 / num1;
                } else if (item.equals("+")) {
                    result = num2 + num1;
                } else if (item.equals("-")) {
                    result = num2 - num1;
                } else {
                    throw new RuntimeException("运算符不正确！");
                }

                stack.push(result + "");
            }
        }

        return Integer.parseInt(stack.pop());
    }

    /**
     * 把中缀表达式转为List形式
     *
     * @param infix
     * @return
     */
    public static List<String> stringToList(String infix) {
        List<String> items = new ArrayList<>();

        int index = 0;
        String exp = "";
        while (index < infix.length()) {
            if (infix.charAt(index) == 32) {   //空格就跳过
                index++;
                continue;

            } else if (infix.charAt(index) > 47 && infix.charAt(index) < 58) {   //如果是数字，判断后一位是不是也是数字。
                exp += infix.charAt(index);
                while (index + 1 <= infix.length() - 1 && infix.charAt(index + 1) > 47 && infix.charAt(index + 1) < 58) {
                    index++;
                    exp += infix.charAt(index);
                }
                index++;
            } else {  //非数字默认为一个运算符或者'(' , ')'
                exp += infix.charAt(index);
                index++;
            }

            items.add(exp);
            exp = "";
        }
        return items;
    }


    public static int getOperatePriority(String operation) {
        int res = 0;

        switch (operation) {
            case "*":
                res = 2;
                break;
            case "/":
                res = 2;
                break;
            case "-":
                res = 1;
                break;
            case "+":
                res = 1;
                break;
            default:
                throw new RuntimeException("运算符有误！");
        }

        return res;
    }

}

```

