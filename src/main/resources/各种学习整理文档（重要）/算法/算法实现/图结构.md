# 													图结构

## 1、 图基本介绍 

### 1.1、 为什么要有图 

1) 前面我们学了线性表和树 

2) 线性表局限于一个直接前驱和一个直接后继的关系 

3) 树也只能有一个直接前驱也就是父节点 

4) 当我们需要**表示多对多**的关系时， 这里我们就用到了**图**。 



### 1.2 、图的举例说明 

图是一种**数据结构**，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 

结点也可以称为 顶点。如图

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\图介绍.png)



### 1.3 、图的常用概念

1) 顶点(vertex) 

2) 边(edge) 

3) 路径 

4) 无向图(右图）

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\定点、边和无向图.png)

5) 有向图 

6) 带权图

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\有向图和带权图.png)



## 2、 图的表示方式 

图的表示方式有两种：**二维数组表示（邻接矩阵）；链表表示（邻接表）**。 



### 2.1 邻接矩阵 

邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1....n 

个点

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\邻接矩阵表示图.png)

### 2.2 邻接表 

1) 邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失. 

2) 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成 

3) 举例说明

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\邻接表表示图.png)





## 3、 图的快速入门案例 

1) 要求: 代码实现如下图结构

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\练手图例1.png)

2) 思路分析 (1) 存储顶点 String 使用 ArrayList (2) 保存矩阵 int[][] edges 

3) 代码实现



## 4、图的遍历

### 4.1 图遍历介绍 

所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种 

访问策略: (1)深度优先遍历 (2)广度优先遍历 



### 4.2、图深度优先遍历介绍 

#### 4.2.1 深度优先遍历基本思想 

图的深度优先搜索(**Depth First Search**) 。 

1) 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问 

第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解： 

每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 

2) 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。 

3) 显然，深度优先搜索是一个递归的过程 



#### 4.4.2 深度优先遍历算法步骤 

1) 访问初始结点 v，并标记结点 v 为已访问。 

2) 查找结点 v 的第一个邻接结点 w。 

3) 若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。 

4) 若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123）。 

5) 查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤 3。 

6) 分析图



#### 4.4.3 深度优先算法的代码实现

```
/**
 * 图的深度遍历搜索算法
 * @param isVisited 记录顶点是否被访问的数组
 * @param preIndex 当前访问的顶点
 */
public void dfs(boolean[] isVisited, int preIndex) {
    //访问preIndex顶点值
    System.out.print(getValueByIndex(preIndex)+"->");

    //标识该顶点已经访问过了
    isVisited[preIndex]=true;

    //获取顶点preIndex的第一个相邻顶点
    int w = getFirstNeighbor(preIndex);

    while (w != -1) {
        //如果相邻顶点没有访问过，以该相邻顶点为起始顶点遍历
        if (!isVisited[w]){
            dfs(isVisited,w);
        }

        //如果相邻顶点已经访问过，获取下一个相邻顶点做遍历
        w=getNextNeighbor(preIndex,w);

    }

}

/**
 * 重载深度遍历搜索算法
 */
public void dfs() {

    isVisited = new boolean[this.vertex.size()];
    //遍历所有的结点，进行 dfs[回溯]
    for (int i = 0; i <this.vertex.size() ; i++) {
        if (!isVisited[i]) {
            dfs(isVisited,i);
        }
    }

}
```



### 4.3、图的广度优先遍历 

#### 4.3.1 广度优先遍历基本思想 

1) 图的广度优先搜索(Broad First Search) 。 

2) 类似于一个**分层搜索**的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来 

访问这些结点的邻接结点 



#### 4.3.2 广度优先遍历算法步骤 

1) 访问初始结点 v 并标记结点 v 为已访问。 

2) 结点 v 入队列

3) 当队列非空时，继续执行，否则算法结束。 

4) 出队列，取得队头结点 u。 

5) 查找结点 u 的第一个邻接结点 w。 

6) 若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤： 

​	6.1 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。 

​	6.2 结点 w 入队列 

​	6.3 查找结点 u 的继 w 邻接结点后的下一个邻接结点 w，转到步骤 6。



#### 4.3.3 广度优先遍历算法代码

```
**
 * 广度优先遍历算法
 * @param isVisited 已访问顶点数组
  * @param i 当前访问顶点
 */
public void bfs(boolean[] isVisited, int i) {
    int u; //队列头节点对应下标

    int w;  //邻接节点w
    //访问当前节点
    System.out.print(getValueByIndex(i)+"=>");
    //标记已经访问过
    isVisited[i]=true;

    //顶点入队
    LinkedList<Integer> queue=new LinkedList<>();
    queue.addLast(i);

    while (!queue.isEmpty()) {
        u = queue.removeFirst();

        w = getFirstNeighbor(u);

        while (w != -1) {

            //是否访问过
            if (!isVisited[w]) {
                //访问当前节点
                System.out.print(getValueByIndex(w)+"=>");
                //标记已经访问过
                isVisited[w]=true;
                //节点入队
                queue.addLast(w);
            }

            ////以 u 为前驱点，找 w 后面的下一个邻结点
            w= getNextNeighbor(u, w);
        }

    }
}

/**
 * 重载广度优先算法
 */
public void bfs() {
    isVisited=new boolean[this.vertex.size()];

    for (int i = 0; i <this.vertex.size() ; i++) {
        if (!isVisited[i]){
            bfs(isVisited,i);
        }
    }

}
```



### 4.4、深度优先和广度优先算法汇总

```
package com.algorithm.graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

public class GraphDemo {
    public static void main(String[] args) {

        int i=8;
        //String[] vertex={"A","B","C","D","E"};

        String[] vertex = {"1", "2", "3", "4", "5", "6", "7", "8"};
        Graph graph = new Graph(i);
        Arrays.stream(vertex).forEach(graph::insertVertex);

        //添加边
        // A-B A-C B-C B-D B-E
      /*  graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(1, 2, 1);
        graph.insertEdge(1, 3, 1);
        graph.insertEdge(1, 4, 1);*/

        graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(1, 3, 1);
        graph.insertEdge(1, 4, 1);
        graph.insertEdge(3, 7, 1);
        graph.insertEdge(4, 7, 1);
        graph.insertEdge(2, 5, 1);
        graph.insertEdge(2, 6, 1);
        graph.insertEdge(5, 6, 1);


        //显示邻接矩阵
        graph.showGraph();

        System.out.println("深度遍历");

        graph.dfs();

     /*   System.out.println("广度遍历");
        graph.bfs();*/
    }
}

class Graph{
    private ArrayList<String> vertex; //保存顶点

    private int[][] edges; //二维数组保存边

    private int numOfEdges; //边的数量

    private boolean[] isVisited; //记录顶点是否被访问


    //这个图有多少顶点
    public Graph(int num) {
        this.vertex=new ArrayList<>(num);
        isVisited=new boolean[num];
        edges=new int[num][num];
    }


    /**
     * 获取n顶点的第一个相连的顶点
     * @param n 标识获取的哪个顶点的第一个相邻顶点
     * @return 获取第一个相连顶点的坐标。如果不存在返回-1
     */
    public int getFirstNeighbor(int n) {
        for (int i = 0; i <this.vertex.size() ; i++) {
            if (edges[n][i] > 0) {
                return i;
            }

        }

        return -1;
    }

    /**
     * 根据前一个邻接结点的下标来获取下一个邻接结点
     * @param v1 当前搜索的节点
     * @param preVertex 前一个邻接结点的下标
     * @return 下一个邻接结点下标
     */
    public int getNextNeighbor(int v1, int preVertex) {

        for (int i = preVertex+1; i <this.vertex.size() ; i++) {
            if (edges[v1][i] > 0) {
                return i;
            }
        }

        return -1;

    }

    /**
     * 图的深度遍历搜索算法
     * @param isVisited 记录顶点是否被访问的数组
     * @param preIndex 当前访问的顶点
     */
    public void dfs(boolean[] isVisited, int preIndex) {
        //访问preIndex顶点值
        System.out.print(getValueByIndex(preIndex)+"->");

        //标识该顶点已经访问过了
        isVisited[preIndex]=true;

        //获取顶点preIndex的第一个相邻顶点
        int w = getFirstNeighbor(preIndex);

        while (w != -1) {
            //如果相邻顶点没有访问过，以该相邻顶点为起始顶点遍历
            if (!isVisited[w]){
                dfs(isVisited,w);
            }

            //如果相邻顶点已经访问过，获取下一个相邻顶点做遍历
            w=getNextNeighbor(preIndex,w);

        }

    }

    /**
     * 重载深度遍历搜索算法
     */
    public void dfs() {

        isVisited = new boolean[this.vertex.size()];
        //遍历所有的结点，进行 dfs[回溯]
        for (int i = 0; i <this.vertex.size() ; i++) {
            if (!isVisited[i]) {
                dfs(isVisited,i);
            }
        }

    }

    /**
     * 广度优先遍历算法
     * @param isVisited 已访问顶点数组
      * @param i 当前访问顶点
     */
    public void bfs(boolean[] isVisited, int i) {
        int u; //队列头节点对应下标

        int w;  //邻接节点w
        //访问当前节点
        System.out.print(getValueByIndex(i)+"=>");
        //标记已经访问过
        isVisited[i]=true;

        //顶点入队
        LinkedList<Integer> queue=new LinkedList<>();
        queue.addLast(i);

        while (!queue.isEmpty()) {
            u = queue.removeFirst();

            w = getFirstNeighbor(u);

            while (w != -1) {

                //是否访问过
                if (!isVisited[w]) {
                    //访问当前节点
                    System.out.print(getValueByIndex(w)+"=>");
                    //标记已经访问过
                    isVisited[w]=true;
                    //节点入队
                    queue.addLast(w);
                }

                ////以 u 为前驱点，找 w 后面的下一个邻结点
                w= getNextNeighbor(u, w);
            }

        }
    }

    /**
     * 重载广度优先算法
     */
    public void bfs() {
        isVisited=new boolean[this.vertex.size()];

        for (int i = 0; i <this.vertex.size() ; i++) {
            if (!isVisited[i]){
                bfs(isVisited,i);
            }
        }

    }

    /**
     * 根据下标获取该下标对应的顶点
     * @param index 下标
     * @return 下标对应的顶点
     */
    public String getValueByIndex(int index) {
        return vertex.get(index);
    }


    public void insertVertex(String vertex) {
        this.vertex.add(vertex);
    }

    public void insertEdge(int v1, int v2, int num) {
        this.edges[v1][v2]=num;
        this.edges[v2][v1]=num;
    }


    public void showGraph() {
        for (int i = 0; i <this.vertex.size() ; i++) {
            for (int j = 0; j <this.vertex.size() ; j++) {
                System.out.print(this.edges[i][j]+" ");
            }
            System.out.println("");
        }
    }

}
```









5、图的深度优先VS 广度优先

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\深度优先遍历和广度优先遍历的区别.png)