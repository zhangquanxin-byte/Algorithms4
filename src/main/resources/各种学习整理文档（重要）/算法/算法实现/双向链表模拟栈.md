# 					                                                双向链表模拟栈

```
package com.algorithm;

import java.util.Scanner;

public class ImitateStackWithLinkedList {
    public static void main(String[] args) {
        LinkedStack stack = new LinkedStack();
        Scanner scanner = new Scanner(System.in);
        boolean flag=true;
        String key="";
        while (flag){
            System.out.println("show: 表示显示栈");
            System.out.println("exit: 退出程序");
            System.out.println("push: 表示添加数据到栈(入栈)");
            System.out.println("pop: 表示从栈取出数据(出栈)");
            System.out.println("请输入你的选择");
            key = scanner.next();

            switch (key) {
                case "s":
                    stack.list();
                break;
                case "push":
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try {
                        int res = stack.pop();
                        System.out.printf("出栈的数据是 %d\n", res);
                    }catch (Exception e) {
                        System.out.println(e.getMessage());
                    }break;
                case "e":
                    scanner.close();
                    flag = false;
                    break;
                default:
                    break;
           }
        }

        System.out.println("程序退出~~~");
    }
}

class LinkedStack {
    private Node head = new Node(0,0);

    private int max=5;

    private Node top=head;

    public boolean isFull() {
        if (size()==max){
            return true;
        }

        return false;
    }

    public boolean isEmpty() {
        if (head.getNext() == null) {
            return true;
        }

        return false;
    }

	//入栈
    public void push(int data) {
        if (isFull()) {
            System.out.println("栈已满，不能放数据了！");
            return;
        }
        Node node = new Node(top.getNo() + 1, data);
        top.setNext(node);
        node.setPro(top);
        top=node;
    }

	//出栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空，不能取数！");
        }

        int res=top.getData();
        top=top.getPro();
        top.setNext(null);
        return res;
    }

	//判断当前栈中有多少数据（可以直接查询top.getNo()）
    public int size() {
        Node temp=head;
        while (true) {
            if (temp.getNext()==null) return temp.getNo();
            temp=temp.getNext();
        }
    }

	//从栈顶遍历栈
    public void list(){
        if (top == head) {
            System.out.println("当前栈为空栈！");
            return;
        }
		//辅助节点移动遍历数组
        Node temp=top;

        while (true) {
            System.out.printf("当前出栈位置top[%d]=%d",temp.getNo(),temp.getData());
            System.out.println("");
            if (temp.getPro()==head) break;

            temp=temp.getPro();
        }
    }

}


class Node {
    private int no;

    private int data;

    private Node next;

    private Node pro;

    public Node(int no, int data) {
        this.no = no;
        this.data = data;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public Node getPro() {
        return pro;
    }

    public void setPro(Node pro) {
        this.pro = pro;
    }

    public int getData() {
        return data;
    }

    public void setData(int data) {
        this.data = data;
    }
}
```