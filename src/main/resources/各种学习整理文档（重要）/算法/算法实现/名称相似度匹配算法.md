# 					名称相似度匹配算法

在处理数据时，有时需要找出数据中存在错误的数据或者对数据进行去重。对数据去重，如果存储在数据库中，我想一个sql就可以搞定，可是要找出数据中错误的数据，就比较困难，一般只能人工判断。举例：比如有一批账单中，存储的都是企业的名称，但想统计一下具体真正的有多少企业，我们可能会说，如果是数据库中，直接distinct一下不就出来了？对，我们可以使用distinct把重复的企业去掉，但是看看留下的企业名称是什么样子，“XXX科技股份有限公司”,'XXX科技股有限公司”，只要名称是人工手工输入的就不免会出错，前面的两个名称用sql统计肯定会认为是两家公司，可用人眼一看就知道，这两个是一家企业。那么，如果出现这种情况，怎样让计算机帮助我们找出这些出错的企业名称呢？

在这里向您推荐一个Levenshtein算法，通过此算法，可以算出两个文本之间的一个阈值，我们简单称它为相似度。现在假设数据库中存在一个企业名称表，里面的名称都是手工输入的，我们可以通过此算法，计算出企业名称两两比较的相似度。一般我们把这个阈值设置到0.8以上时，几乎能够找出所有的人工手工输入的错误。在实际应用中，我们可以将这个阈值存入数据库中，在阈值中筛选一个合适的阈值，就能把相似的名称都找出。

下面是一个Java代码示例：



```
public class DeleteRepeatData {

public static float levenshtein(String str1, String str2) {
    //计算两个字符串的长度。
    int len1 = str1.length();
    int len2 = str2.length();
    //建立上面说的数组，比字符长度大一个空间
    int[][]dif = new int[len1 + 1][ len2 + 1];
    //赋初值，步骤B。
    for (int a = 0; a <= len1; a++) {
        dif[a][0] =a;
    }
    for (int a = 0; a <= len2; a++) {
        dif[0][a] =a;
    }
    //计算两个字符是否一样，计算左上的值
    char [] ch1 = str1.toCharArray();
    char [] ch2 = str2.toCharArray();
    int temp;
    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            if (ch1[i - 1] == ch2[j - 1]) {
                temp = 0;
            } else {
                temp = 1;
            }
            //取三个值中最小的
            int temp1 = dif[i - 1][j - 1]+temp;
            int temp2 = dif[i][j - 1]+1;
            int temp3 = dif[i - 1][j]+1;
            int arr [] =  new int[]{temp1,temp2, temp3};
       dif[i][j] =min(arr);
    }
}
//计算相似度
float similarity = 1 - (float) dif[len1][len2] /Math.max(str1.length(), str2.length());
return similarity;
}

//得到最小值
private static int min(int[]arr) {
    int min = arr[0];
    for( int i :arr){
        if (min > i) {
            min = i;
        }
    }
    return min;
}
}
```


调用实例：

public static void main(String[] args) {
        String str = "这是第一行内容";
        String str2 = "这是第二行内容";
        System.out.println("相似度是："+DeleteRepeatData.levenshtein(str,str2));
}
