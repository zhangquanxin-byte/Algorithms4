# 				    排序算法

## 1、排序算法的介绍 

排序也称排序算法(Sort Algorithm)，排序是将**一组数据**，依**指定的顺序**进行**排列的过程**。



## 2、排序的分类： 

1) 内部排序: 

指将需要处理的所有数据都加载到**内部存储器**(内存)中进行排序。 

2) 外部排序法： 

**数据量过大**，无法全部加载到内存中，需要借助**外部存储**(文件等)进行排序。 

3) 常见的排序算法分类(见右图): 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\常见算法.png)





## 3、算法的时间复杂度

3.1、度量一个程序(算法)执行时间的两种方法

1) 事后统计的方法 

这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所 

得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。 



2) 事前估算的方法 

通过分析某个算法的**时间复杂度**来判断哪个算法更优.



3.2、时间频度 

基本介绍 

时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间 

就多。**一个算法中的语句执行次数称为语句频度或时间频度**。记为 T(n)。



3.3、时间复杂度 

1) 一般情况下，**算法中的基本操作语句的重复执行次数是问题规模** **n** **的某个函数**，用 T(n)表示，若有某个辅 

助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。 

记作 **T(n)=**Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 

2) T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 

它们的 T(n) 不同，但时间复杂 

度相同，都为 **O(n**²)。 

3) 计算时间复杂度的方法： 

用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 => T(n)=n²+7n+1 

修改后的运行次数函数中，只保留最高阶项 

T(n)=n²+7n+1 => T(n) = n² 

去除最高阶项的系数 T(n) = n² => T(n) = n² 

=> O(n²) 



3.4、常见的时间复杂度

1) 常数阶 O(1) 

2) 对数阶 O(log2n) 

3) 线性阶 O(n) 

4) 线性对数阶 O(nlog2n)

5) 平方阶 O(n^2) 

6) 立方阶 O(n^3) 

7) k 次方阶 O(n^k) 

8) 指数阶 O(2^n)

**常见的时间复杂度对应的图**:

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\常见的时间复杂度对应的图.png)

**说明**：

1) 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ 

Ο(nk) ＜ Ο(2n) ，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低 

2) 从图中可见，我们应该尽可能避免使用指数阶的算法



3.5、平均时间复杂度和最坏时间复杂度 

1) 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 

2) 最坏情况下的时间复杂度称最坏时间复杂度。**一般讨论的时间复杂度均是最坏情况下的时间复杂度**。这样做的 

原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会 

比最坏情况更长。 

3) 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\平均时间复杂度和最坏时间复杂度.png)





## 4、算法的空间复杂度简介 

4.1基本介绍 

1) 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是 

问题规模 n 的函数。 

2) 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的 

临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例 

如快速排序和**归并排序算法****,** **基数排序**就属于这种情况 

3) 在做算法分析时，主要讨论的是时间复杂度。**从用户使用体验上看，更看重的程序执行的速度**。一些缓存产品 

(redis, memcache)和算法(基数排序)**本质就是用空间换时间**.





## 5、冒泡排序 

### 5.1、基本介绍 

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,**依次比较** 

**相邻元素的值，若发现逆序则交换**，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

优化： 

因为排序的过程中，各元素不断接近自己的位置，**如果一趟比较下来没有进行过交换，就说明序列有序**，因此要在 

排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。



5.2、**代码实现**:

```
package com.algorithm;

import java.text.SimpleDateFormat;
import java.util.Date;

public class BubbleSort {
    public static void main(String[] args) {
        //int[] arr={12,5,2,7,-1};

        int[] arr= new int[80000];
        for (int i = 0; i <80000 ; i++) {
            arr[i]=(int)(Math.random()*800000);
        }

        System.out.println("排序前：");
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String format1 = dateFormat.format(new Date());
        System.out.println("时间 = " + format1);


        bubbleSort(arr);
        System.out.println("排序后：");
        String format2 = dateFormat.format(new Date());
        System.out.println("时间 = " + format2);

    }


    /**
     * 从小到大排序
     * @param arr
     */
    public static void bubbleSort(int[] arr) {

        int temp;
        boolean flag=false;
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j <arr.length-1-i ; j++) {
                if (arr[j] > arr[j + 1]) {
                    flag=true;
                    temp=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
            }

            if (!flag) {
                break;
            }else {
                flag=false;
            }
        }
    }

    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i+ " ");
        }

        System.out.println("");
    }
}
```







## 6、选择排序

### 6.1、基本介绍 

选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到 

排序的目的。 



### 6.2、选择排序思想

选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]~arr[n-1]中选取最小值， 与 arr[0]交换，第二次从 arr[1]~arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]~arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]~arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列





### 6.3、选择排序代码

```
package com.algorithm;

import java.text.SimpleDateFormat;
import java.util.Date;

public class SelectSort {
    public static void main(String[] args) {
        int[] arr= new int[80000];
        for (int i = 0; i <80000 ; i++) {
            arr[i]=(int)(Math.random()*800000);
        }

        System.out.println("排序前：");
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String format1 = dateFormat.format(new Date());
        System.out.println("时间 = " + format1);
        //printArray(arr);

        selectSort(arr);
        System.out.println("排序后：");
        String format2 = dateFormat.format(new Date());
        System.out.println("时间 = " + format2);
        //printArray(arr);
    }

    /**
     * 从小到大排序
     * @param arr
     */
    public static void selectSort(int[] arr) {

        int index;
        int minVal;
        for (int i = 0; i <arr.length-1 ; i++) {
            minVal=arr[i];
            index=i;
            for (int j = i+1; j <arr.length-1 ; j++) {
                if (minVal>arr[j]){
                    minVal=arr[j];
                    index=j;
                }
            }

            //最小值不是该轮循环第一位，将第一位和最小数值位数值对调
            if (index != i) {
                arr[index]=arr[i];
                arr[i]=minVal;
            }
        }
    }

    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i+ " ");
        }

        System.out.println("");
    }
}
```





## 7、插入排序 

### 7.1、插入排序法介绍: 

插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。 



### 7.2、插入排序法思想: 

插入排序（Insertion Sorting）的基本思想是：**把** **n** **个待排序的元素看成为一个有序表和一个无序表**，开始时**有** 

**序表中只包含一个元素**，无序表中包含有 **n-1** **个元素**，排序过程中每次从无序表中取出第一个元素，把它的排 

序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。



### 7.3、代码

```
package com.algorithm;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class InsertSort {
    public static void main(String[] args) {

        int[] arr= new int[80000];
        for (int i = 0; i <80000 ; i++) {
            arr[i]=(int)(Math.random()*800000);
        }


        System.out.println("排序前：");
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String format1 = dateFormat.format(new Date());
        System.out.println("时间 = " + format1);

        //排序
        selectSort(arr);
        System.out.println("排序后：");
       // System.out.println(Arrays.toString(arr));


        String format2 = dateFormat.format(new Date());
        System.out.println("时间 = " + format2);

    }


    /**
     * 从小到大排序
     *
     * @param arr
     */
    public static void selectSort(int[] arr) {
        int insertIndex;
        int insertVal;

        for (int i=1; i < arr.length; i++) {

            insertIndex = i-1;   //插入位置
            insertVal = arr[i];  //插入的值

			//在寻找插入元素位置的过程中，循环把元素往后移动
            //找到之后退出
            while (insertIndex >= 0 && insertVal < arr[insertIndex]) {
                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }


            //找打的位置是比插入的值小的数组位置。所以应该插入的位置是该位置+1
            if (insertIndex+1 != i) {
                arr[insertIndex+1] = insertVal;
            }
        }

    }
}
```





## 8、希尔排序 

### 8.1、简单插入排序的缺点 

我们看简单的插入排序可能存在的问题. 

数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1**(****最小**), 这样的过程是： 

{2,3,4,5,6,6} 

{2,3,4,5,5,6} 

{2,3,4,4,5,6} 

{2,3,3,4,5,6} 

{2,2,3,4,5,6} 

{1,2,3,4,5,6} 

**结论:** 当**需要插入的数是较小的数时**，**后移的次数明显增多**，对**效率**有影响. 



### 8.2、希尔排序法介绍 

希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种**插入排序**，它是简单插入

排序经过改进之后的一个**更高效的版本**，也称为**缩小增量排序**。 



### 8.3、希尔排序法基本思想 

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含 

的关键词越来越多，**当增量减至** **1** 时，整个文件恰被分成一组，算法便终止



### 8.4、希尔排序法的示意图

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\希尔排序示意图.png)





### 8.5、代码实现

```
package com.algorithm;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class ShellSort {
    public static void main(String[] args) {
        int[] arr= new int[11];
        for (int i = 0; i <11 ; i++) {
            arr[i]=(int)(Math.random()*80);
        }


        System.out.println("排序前：");
       // System.out.println(Arrays.toString(arr));

        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String format1 = dateFormat.format(new Date());
        System.out.println("时间 = " + format1);

        //排序
        shellSort(arr);
        System.out.println("排序后：");
        System.out.println(Arrays.toString(arr));


        String format2 = dateFormat.format(new Date());
        System.out.println("时间 = " + format2);
    }

    /**
     * 从小到大排序
     * @param arr
     */
    public static void shellSort(int[] arr) {

        //shell排序每次的步长取数组长度的1/2
        for (int gap=arr.length/2;gap>=1;gap/=2) {
            for (int i = gap; i < arr.length; i++) {
                int index = i - gap;  //插入位置
                int value = arr[i];   //准备插入的值

                //用简单插入排序给每一一个分组排序
                if (arr[i] < arr[index]) {  //如果当前元素小于有序数组的最后一个元素。确实需要移动
                    while (index >= 0 && value < arr[index]) {   //在寻找插入元素位置的过程中，循环把元素往后移动
                        arr[index + gap] = arr[index];
                        index -= gap;
                    }

                    // 由于最后做了一次index -= gap;需要把插入元素位置+gap步长
                    arr[index + gap] = value;
                }
            }
        }

    }
}
```





## 9.1、快速排序 （待研究DualPivotQuicksort）

### 9.1快速排序法介绍: 

快速排序（Quicksort）是对**冒泡排序**的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两 

部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排 

序，**整个排序过程可以递归进行**，以此达到整个数据变成有序序列



### 9.2快速排序法示意图:

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\排序法示意图.png)







### 9.3、快速排序思路

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\快速排序思路.PNG)





### 9.4、代码实现

```
package com.algorithm;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class QuickSort {
    public static void main(String[] args) {
        int[] arr= new int[8000000];
        for (int i = 0; i <8000000 ; i++) {
            arr[i]=(int)(Math.random()*80000000);
        }


        System.out.println("排序前：");
        //System.out.println(Arrays.toString(arr));

        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String format1 = dateFormat.format(new Date());
        System.out.println("时间 = " + format1);

        //排序
        quickSort(arr,0,arr.length-1);
        System.out.println("排序后：");
        //System.out.println(Arrays.toString(arr));


        String format2 = dateFormat.format(new Date());
        System.out.println("时间 = " + format2);


    }

    public static void quickSort(int[] arr,int left,int right) {
        int l=left;
        int r=right;
        //pivot 中轴值
        int pivot=arr[(l+r)/2];
        int temp;

        //while 循环的目的是让比 pivot 值小放到左边//比 pivot 值大放到右边
        while (l < r) {
            //在 pivot 的左边一直找,找到大于等于 pivot 值,才退出。  r和l交会的坐标不一定是pivot
            while (arr[l] < pivot) {
                l++;
            }

            //在 pivot 的右边一直找,找到小于等于 pivot 值,才退出
            // r和l交会的坐标不一定是pivot  如果右边没有比pivot小的值。左边有2个比pivot大的值
            //经过一轮替换，r当前坐在下标的值比pivot大。r又会走过pivot所在下标往l靠拢
            while (arr[r] > pivot) {
                r--;
            }

            //如果 l >= r 说明 pivot 的左右两的值，已经按照左边全部是 //小于等于 pivot 值，右边全部是大于等于 pivot 值
            if (l >= r) {
                break;
            }

            temp=arr[l];
            arr[l]=arr[r];
            arr[r]=temp;

            //如果交换完后，发现这个 arr[l] == pivot 值 相等 r--， 前移.不然r就卡住了,不会往左移动
            if (arr[l] == pivot) {
                r--;
            }

            //如果交换完后，发现这个 arr[r] == pivot 值 相等 l++， 后移。不然l就卡住了,不会往右移动
            if (arr[r] == pivot) {
                l++;
            }
        }

        // 如果 l == r, 必须 l++, r--, 否则为出现栈溢出
        if (l == r) {
            l += 1;
            r -= 1;
        }


        if(left < r) {
            quickSort(arr, left, r);
        }

        if(right > l) {
            quickSort(arr, l, right);
        }
    }
}
```



## 9.2、DualPivotQuicksort(待研究)

jdk1.7默认排序算法。对经典快排的优化





## 10 、归并排序 

### 10.1、 归并排序介绍: 

归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的**分治（****divide-and-conquer****）** 

**策略**（分治法将问题分(divide)成一些**小的问题然后递归求解**，而治(conquer)的阶段则将分的阶段得到的各答案"修 补"在一起，即分而治之)



### 10.2、 归并排序基本思想:

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\归并排序思想示意图.png)



### 10.3、 归并排序思想示意图 2-合并相邻有序子序列: 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\归并排序思想示意图2.png)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\归并排序思想示意图3.png)

### 10.4、 归并排序的应用实例:

给你一个数组, val arr = Array(8, 4, 5, 7, 1, 3, 6, 2 ), 请使用归并排序完成排序。

```
package com.algorithm;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class MergeSort {
    public static void main(String[] args) {
        int[] arr= new int[8000000];
        for (int i = 0; i <8000000 ; i++) {
            arr[i]=(int)(Math.random()*80000000);
        }


        int[] temp = new int[arr.length];


        System.out.println("排序前：");
        //System.out.println(Arrays.toString(arr));

        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String format1 = dateFormat.format(new Date());
        System.out.println("时间 = " + format1);

        //排序
        divideAndMerge(arr,0,arr.length-1,temp);
        System.out.println("排序后：");
        //System.out.println(Arrays.toString(arr));


        String format2 = dateFormat.format(new Date());
        System.out.println("时间 = " + format2);

    }


    /**
     * 分+治
     * @param arr
     * @param left
     * @param right
     * @param temp
     */
    public static void divideAndMerge(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid=(left+right)/2;

            //向左递归进行分解
            divideAndMerge(arr,left,mid,temp);
            //向右递归进行分解
            divideAndMerge(arr,mid+1,right,temp);
            //合并
            merge(arr,left,mid,right,temp);
        }
    }


    /**
     * 从小到大排序,并复制到arr数组
     * @param arr
     * @param left
     * @param mid
     * @param right
     */
    public static void merge(int[] arr, int left, int mid, int right,int[] temp) {
        int l=left;  // 指向当前数组的左边
        int r=mid+1;  //指向当前数组的中间
        int t = 0;  //指向temp数组

        //将数组按从小到大排序放到temp数组
        while (l <= mid && r <= right) {
            if (arr[l] <= arr[r]) {
                temp[t]=arr[l];
                l++;
                t++;
            }

            if (arr[r] <= arr[l]) {
                temp[t]=arr[r];
                t++;
                r++;
            }
        }


        //将剩余未放到temp里的按顺序放入
        if (l <= mid) {
            while (l <= mid) {
                temp[t]=arr[l];
                t++;
                l++;
            }
        }

        if (r <= right) {
            while (r <= right) {
                temp[t]=arr[r];
                t++;
                r++;
            }
        }


        //将 temp 数组的元素拷贝到 arr
        // 注意，并不是每次都拷贝所有
        //第一次合并 tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tL=0 ri=3 //最后一次 tempLeft = 0 right = 7
        int tempLeft=left;
        int tempT=0;
        //将temp数组copy到arr数组
        while (tempLeft <= right) {
            arr[tempLeft]=temp[tempT];
            tempT++;
            tempLeft++;
        }
    }
}
```







## 11、基数排序 

11.1、 基数排序(桶排序)介绍: 

基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾 

名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 

2) 基数排序法是属于稳定性的排序，基数排序法的是效率高的**稳定性**排序法 

3) 基数排序(Radix Sort)是桶排序的扩展 

4) 基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个 

位数分别比较。 



11.2、 基数排序基本思想 

1) 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 

这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。



11.3 、基数排序图文说明

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\基数排序图文1.PNG)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\基数排序图文2.PNG)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\基数排序图文3.PNG)





11.4、 基数排序代码实现 

要求：将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序 

```
package com.algorithm;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class RadixSort {
    public static void main(String[] args) {

        int[] arr= new int[80000000];
        for (int i = 0; i <80000000 ; i++) {
            arr[i]=(int)(Math.random()*800000000);
        }
        //int[] arr ={53, 3, 542, 748, 14, 214};

        System.out.println("排序前：");
        //System.out.println(Arrays.toString(arr));

        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String format1 = dateFormat.format(new Date());
        System.out.println("时间 = " + format1);

        //排序
        radisSort(arr);
        System.out.println("排序后：");
        //System.out.println(Arrays.toString(arr));


        String format2 = dateFormat.format(new Date());
        System.out.println("时间 = " + format2);

    }


    public static void radisSort(int[] arr) {

        //获取待排序数组中最大数的长度。已确定需要进行多少次基排序
        int max = arr[0];

        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }

        int maxLength = (max + "").length();

		//定义一个二维数组，表示 10 个桶, 每个桶就是一个一维数组
        //将arr数组中的数据依次按个位，十位，百位依次类推入桶
        //存放数据的长为10，一维数组长为arr数组长的二维数组作为放数据的桶
        //基数排序是使用空间换时间的经典算法
        int[][] buckets = new int[10][arr.length];

        //记录每个桶在每次排序时实际存放了多少个数据
        //比如：numOfEachBucket[0] , 记录的就是 buckets[0] 桶的放入数据个数
        int[] numOfEachBucket = new int[buckets.length];


        for (int m = 0, n = 1; m < maxLength; m++, n *= 10) {

            //将每个arr数据按某一位上的数字放入不同的桶子中
            for (int i = 0; i < arr.length; i++) {
                //判断数据个位数数值
                int digitOfElement = arr[i] / n % 10;
                buckets[digitOfElement][numOfEachBucket[digitOfElement]] = arr[i];
                numOfEachBucket[digitOfElement]++;
            }

            //每次将桶中数据放回arr数组时从0开始
            int index = 0;
            //将桶子中的数据取出放回arr数组
            for (int i = 0; i < numOfEachBucket.length; i++) {
                if (numOfEachBucket[i] > 0) {
                    for (int j = 0; j < numOfEachBucket[i]; j++) {
                        arr[index++] = buckets[i][j];
                    }


                    //标识桶中数据的值置为0
                    numOfEachBucket[i] = 0;
                }
            }


        }

    }
}
```



## 12、堆排序

### 12.1 、堆排序基本介绍 

1) 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 

杂度均为 **O(nlogn)**，它也是不稳定排序。 

2) 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 

注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。 

3) 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 

4) 大顶堆举例说明

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\大顶推介绍.png)

5) 小顶堆举例说明 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\小顶堆介绍.png)



6) 一般升序采用大顶堆，降序采用小顶堆



### 12.2、 堆排序基本思想 

堆排序的基本思想是： 

1) 将待排序序列构造成一个大顶堆 

2) 此时，整个序列的最大值就是堆顶的根节点。 

3) 将其与末尾元素进行交换，此时末尾就为最大值。 

4) 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序 

序列了。 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了



### 12.3、 堆排序步骤图解说明 

要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。

**步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。**

1) .假设给定无序序列结构如下

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\堆排序无序序列.png)

2).此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\堆排序第一步调整.png)

3) .找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\堆排序第二个非叶节点比较.png)

4) 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\堆排序第二步排序后调整第一步节点.png)

此时，我们就将一个无序序列构造成了一个大顶堆。

**步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**

1) .将堆顶元素9和末尾元素4进行交换

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\堆排序堆顶元素与末尾元素交换.png)

2) .重新调整结构，使其继续满足堆定义

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\堆排序收尾交换后调整结构.png)

3) .再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\堆排序第二次交换后再调整.png)

4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\堆排序无限调整.png)

**再简单总结下堆排序的基本思路：**

**1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;**

**2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;**

**3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。**



### 12.4、 堆排序代码实现 

要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。 

说明： 

1) 堆排序不是很好理解

2) 堆排序的速度非常快， 本地8千万只需1秒左右。O(nlogn) 

代码实现:

```
package com.algorithm.heapSort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class HeapSortDemo {
    public static void main(String[] args) {
       //int arr[] = {4, 6, 8, 5, 9};
        // 创建要给 80000 个的随机的数组
        int[] arr = new int[80000000];
        for (int i = 0; i < 80000000; i++) {
            arr[i] = (int) (Math.random() * 800000000);
        }


        Date date1 = new Date();
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        System.out.println("排序前时间：" + df.format(date1));

        heapSort(arr);

        Date date2 = new Date();
        System.out.println("排序后时间：" + df.format(date2));


        //System.out.println("排序后"+ Arrays.toString(arr));

    }


    /**
     * 从小到大排序：构造大顶堆
     *
     * @param arr 待排序数组
     */
    public static void heapSort(int arr[]) {

        //先将无序序列构造成一个大顶堆
        for (int i = arr.length / 2 - 1; i >= 0; i--) {  //i>=0 这里i=0 指的是根节点
            adjustHeap(arr, i, arr.length);    //第一次调整无序数组，从底向上全部调整一遍。
        }

        //2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
        // 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换 步骤，直到整个序列有序。
        for (int j = arr.length - 1; j > 0; j--) {
            int temp = arr[0];
            arr[0] = arr[j];
            arr[j] = temp;

            adjustHeap(arr, 0, j);   //由于已经做过第一次全部调整，之后每次堆顶元素与末尾元素交换后  除了堆顶元素不满足大顶堆外其余部分均已经满足  只需调整i=0 根节点即可
        }


    }

    /**
     * 调整无序数组为大顶堆
     *
     * @param arr    待调整数组
     * @param i      待调整堆的非叶子节点
     * @param length 有效待调整数组长度
     */
    public static void adjustHeap(int[] arr, int i, int length) {
        //保存i下标所指向数组下标元素
        int temp = arr[i];

        //当前非叶子节点左节点 i=2*i+1
        for (int k = i * 2 + 1; k < length; k = 2 * i + 1) {   //每次都找当前节点的左子节点
            if (k + 1 < length && arr[k + 1] > arr[k]) {  //确保i节点的右子树属于待调整长度以内
                k++;   //如果右子节点比左子节点大，让当前k指向i节点的右子树
            }

            if (arr[k] > arr[i]) {  //如果子节点数值比父节点数值大
                arr[i] = arr[k];   //把较大的值放到上面一层，同时让i指向被k:即原本较大的位置
                i = k;   // i 指向 k,继续循环比较.将下层的树也调整成大顶堆
            } else {
                break;  //如果当前节点已经比左右子树大，下面子树原本就已经被调整完毕
            }
        }

        arr[i] = temp;  //将原本i节点的数据赋给最后一次被调整位置的节点

    }
}
```