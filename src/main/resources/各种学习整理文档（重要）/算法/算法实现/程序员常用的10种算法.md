# 			程序员常用的10种算法

## 1 、二分查找算法(非递归) 

### 1.1 二分查找算法(非递归)介绍 

1) 前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 

2) 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 

3) 二分查找法的运行时间为对数时间 O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n 步，假设从[0,99]的 

队列(100 个数，即 n=100)中寻到目标数 30，则需要查找步数为㏒₂100 , 即最多需要查找 7 次( 2^6 < 100 < 2^7) 



### 1.2 二分查找算法(非递归)代码实现 

数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成. 

1) 思路分析： 

2) 代码实现

```
package com.algorithm.algorithm;

public class BinarySearch {
    public static void main(String[] args) {
        //测试
        int[] arr = {1,3, 8, 10, 11, 67, 100};
        System.out.println("下标：" + binarySearchNoRecursion(arr,2));
    }

    /**
     * 非递归二分查找方式查找目标值
     * @param arr 存放所有数据的数组
     * @param target 目标值
     * @return 目标值所在数组下标。没找到，返回-1
     */
    public static int binarySearchNoRecursion(int[] arr, int target) {
        int left=0; //左边界
        int right=arr.length; //右边界
        int mid;

        while (left <= right) {
            mid = (left+right)/2;

            if (arr[mid] == target) { //数组中点值为目标值
                return mid;
            } else if (arr[mid] > target) {  //数组中点值大于所寻找的值，目标值位于数组左边
                right=mid-1;
            }else { //数组中点值小于所寻找的值，目标值位于数组右边
                left=mid+1;
            }

        }

        return -1;

    }
}
```





## 2、 分治算法 

### 2.1 分治算法介绍 

1) 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或 

相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题 

的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变 

换)…… 

2) 分治算法可以求解的一些经典问题 

二分搜索 

大整数乘法 

棋盘覆盖 

合并排序 

快速排序 

线性时间选择  

最接近点对问题 

循环赛日程表 

**汉诺塔** 



### 2.2 分治算法的基本步骤 

**分治法在每一层递归上都有三个步骤：** 

**1)** **分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题** 

**2)** **解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题**

**3)** **合并：将各个子问题的解合并为原问题的解。**



### 2.3 分治(Divide-and-Conquer(P))算法设计模式

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\分治算法设计模式.png)



### 2.4 分治算法最佳实践-汉诺塔 

汉诺塔的传说 

汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金 

刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小 

顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 

假如每秒钟一次，共需多长时间呢？移完这些金片需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百 

亿年。真的过了 5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 

汉诺塔游戏的演示和思路分析:尚硅谷 Java 数据结构和算法 



1) 如果是有一个盘， A->C 

如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘 

2) 先把 最上面的盘 A->B 

3) 把最下边的盘 A->C 

4) 把 B 塔的所有盘 从 B->C 



汉诺塔游戏的代码实现: 

```
package com.algorithm.algorithm;

public class HanoiTower {
    public static void main(String[] args) {
        hanoiTower(10,'A','B','C');

    }

    public static void hanoiTower(int num,char a, char b, char c){
        if (num == 1) {
            System.out.println("第1个盘从"+a+"——>"+c);
        }else{
            //如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘
            //1. 先把 最上面的所有盘 A->B， 移动过程会使用到 c
            hanoiTower(num-1,a,c,b);
            //2. 把最下边的盘 A->C
            System.out.println("第"+num+"个盘从"+a+"——>"+c);
            //3. 把 B 塔的所有盘 从 B->C , 移动过程使用到 a 塔
            hanoiTower(num-1,b,a,c);
        }
    }
}
```





## 3、动态规划算法 

### 3.1 应用场景-背包问题 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\背包问题.png)

1、要求达到的目标为装入的背包的总价值最大，并且重量不超出
2、要求装入的物品不能重复



### 3.2 动态规划算法介绍 

1) 动态规划(Dynamic Programming)算法的核心思想是：将**大问题划分为小问题**进行解决，从而一步步获取最优解 的处理算法 

2) 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这 

些子问题的解得到原问题的解。 

3) 与分治法不同的是，适合于用动态规划求解的问题，经分解得到**子问题往往不是互相独立的**。 ( 即下一个子 阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 ) 

4) 动态规划可以通过填表的方式来逐步推进，得到最优解





### 3.3 思路分析和图解 

3) 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价 

值最大。其中又分 **01** **背包**和**完全背包**(完全背包指的是：每种物品都有无限件可用) 

4) 这里的问题属于 **01** **背包**，即每个物品最多放一个。而无限背包可以转化为 01 背包。 

5) 算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i]和 v[i]来确定是否需要将该物品 

放入背包中。即对于给定的 n 个物品，设 v[i]、w[i]分别为第 i 个物品的价值和重量，C 为背包的容量。再令 v[i][j] 

表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。则我们有下面的结果：

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\背包问题思路.png)



6）图解的分析

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\填表解决动态规划图解.png)



### 3.4 代码实现

```
package com.algorithm.algorithm;

public class KnapsackProblem {
    public static void main(String[] args) {

        int[] w={1,4,3}; //物品重量数组
        int[] val={1500,3000,2000}; //物品价值数组
        String[] name={"吉他","音像","电脑"};
        int m=4;  //背包容量
        int n=val.length; //物品数量

        //背包中总价值数组 :纵列表示可以存放的物品，横列表示背包的容量。
        // v表示当前物品数量和背包容量下可以存放的最大价值物品
        int[][] v=new int[n+1][m+1];


        //初始化第一行为0
        for (int i = 0; i <n ; i++) {
            v[i][0]=0;
        }

        //初始化第一列为0
        for (int i = 0; i <m ; i++) {
            v[0][i]=0;
        }

        //存放过物品的数组
        int[][] path=new int[n+1][m+1];


        for (int i = 1; i <v.length ; i++) {
            for (int j = 1; j <v[0].length ; j++) {
                //当前物品重量大于背包容量，
                // 当前物品，当前背包容量的可以存放的最大价值=上一个物品，相同背包容量下的可存放最大价值
                if (w[i-1]>j){// 因为我们程序 i 是从 1 开始的，因此原来公式中的 w[i] 修改成 w[i-1]
                    v[i][j]=v[i-1][j];
                }else{
                    //当前物品的重量小于背包容量时，可以尝试往背包存放新的物品。
                    //v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);
                    // 为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用 if-else 来体 现公式
                    if (v[i - 1][j] < val[i - 1] + v[i-1][j - w[i - 1]]) { //存放新物品的总价值大于沿用之前的存放策略
                        v[i][j]=val[i - 1] + v[i-1][j - w[i - 1]];
                        path[i][j]=1;
                    }else {    //存放新物品的总价值小于等于之前的存放策略，当前节点存放的最大商品价值为上一节点的存放策略
                        v[i][j]=v[i-1][j];
                    }
                }


            }
        }


        //输出当前背包的所有存放策略
        for (int i = 0; i <v.length ; i++) {
            for (int j = 0; j <v[0].length ; j++) {
                System.out.print(v[i][j]+" ");
            }
            System.out.println();
        }

        System.out.println("输出一下物品存放策略：");
        for (int i = 0; i <path.length ; i++) {
            for (int j = 0; j <path[0].length ; j++) {
                System.out.print(path[i][j]+" ");
            }
            System.out.println();
        }


        //输出一下最大容量下背包存放的物品
        //遍历 path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入
        int i=path.length-1; //存放背包策略的下标最大值
        int j=path[0].length-1;
        while (i > 0 && j > 0) {
            if (path[i][j] == 1) {
                System.out.println("存放物品："+name[i-1]);
                j-=w[i-1];  //减去当前物品重量
            }

            i--;
        }


    }



}

```





## 4、KMP 算法

### 4.1 字符串匹配问题

1) 有一个字符串 str1= ""硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好""，和一个子串 str2="尚硅谷你尚硅 

你" 

2) 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 



### 4.2 暴力匹配算法 

如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有: 

1) 如果当前字符匹配成功（即 str1[i] == str2[j]），则 i++，j++，继续匹配下一个字符 

2) 如果失配（即 str1[i]! = str2[j]），令 i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0。 

3) 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量 

的时间。(不可行!) 

4) 暴力匹配算法实现. 

5) 代码 

```
package com.algorithm.algorithm;

public class ViolenceMatch {
    public static void main(String[] args) {
        //测试暴力匹配算法
        String str1 = "硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好";
        String str2 = "尚硅谷你尚硅你";
        int index = violenceMatch(str1, str2);
        System.out.println("index=" + index);
    }

    public static int violenceMatch(String origin, String toMatch){
        char[] oriCharArray = origin.toCharArray();
        char[] toMatchCharArray = toMatch.toCharArray();

        int  oriLen=oriCharArray.length; //原字符串长度
        int toMatchLen=toMatchCharArray.length; //待匹配字符串长度

        int o=0; //原字符串数组下标
        int t=0; //待匹配数组下标
        while (o < oriLen && t < toMatchLen) { // 保证匹配时，不越界
            if (oriCharArray[o] == toMatchCharArray[t]) { //匹配 ok
                o++;
                t++;
            }else { //匹配失败   o下标返回到前一次匹配开始点后一个位置。t待匹配数组回到起点重新匹配
                o=o-(t-1);
                t=0;
            }

        }


        if (t == toMatchLen) {
            return o-t;
        }else {
            return -1;
        }




    }


}
```



### 4.3 KMP 算法介绍 

1) KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法 

2) Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的 出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的 姓氏命名此算法. 

3) KMP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次 

回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间 

4) 参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html



### 4.4 KMP 算法最佳应用-字符串匹配问题

字符串匹配问题： 

1) 有一个字符串 str1= "BBC ABCDAB ABCDABCDABDE"，和一个子串 str2="ABCDABD" 

2) 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 

3) 要求：使用 **KMP** **算法完成**判断，不能使用简单的暴力匹配算法.



![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\KMP算法思路分析1.png)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\KMP算法思路分析2.png)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\KMP算法思路分析3.png)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\KMP算法思路分析4.png)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\KMP算法思路分析5.png)





代码：

```
package com.algorithm.algorithm;

import java.util.Arrays;

public class KmpSearch {
    public static void main(String[] args) {
        String str1 = "BBC ABCDABCDABD ABCDABCDABDE";
        String str2 = "ABCDABD";
        int[] kmpNext = kmpNext("ABCDABD");
        System.out.println("kmpNext = " + Arrays.toString(kmpNext));
        int i = kmpSearch(str1, str2, kmpNext);
        System.out.println("i = " + i);

    }


    /**
     * 用kmp算法求出匹配的字符串的下标
     * @param origin 原字符串
     * @param target 待匹配字符串
     * @param next 待匹配字符串部分匹配表
     * @return 匹配字符串下标。没找到返回-1
     */
    public static int kmpSearch(String origin, String target, int[] next) {
        for (int i = 0, j=0; i <origin.length() ; i++) {
            //原数组只遍历一次，所以需要不断调整待匹配字符串下标
            //需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整 j 的大小
            // KMP 算法核心点
            while (j > 0 && origin.charAt(i) != target.charAt(j)) {
                j=next[j-1];
            }

            if (origin.charAt(i) == target.charAt(j)) {
                j++;
            }

            if (j == target.length()) {
                return i-j+1;
            }
        }

        return -1;


    }


    /**
     * 得到目标字符串的部分匹配表
     * @param target 目标字符串
     * @return 部分匹配表数组
     */
    public static int[] kmpNext(String target) {

        int[] next = new int[target.length()];

        //第一个下标必然是0
        for (int i = 1, j=0; i <target.length() ; i++) {

            //当 dest.charAt(i) != dest.charAt(j) ，我们需要从 next[j-1]获取新的 j
            // 直到我们发现 有 dest.charAt(i) == dest.charAt(j)成立才退出
            // 这是kmp 算法的核心点
            while (j > 0 && target.charAt(i) != target.charAt(j)) {
                j=next[j-1];
            }

            if (target.charAt(i) == target.charAt(j)) {
                j++;
            }

            next[i]=j;

        }

        return next;
    }
}
```





## 5、贪心算法 

### 5.1 应用场景-集合覆盖问题 

假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区 

都可以接收到信号 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\覆盖地区.png)



### 5.2 贪心算法介绍 

1) 贪婪算法(贪心算法)是指在对问题进行求解时，**在每一步选择中都采取最好或者最优*(即最有利****)*的选择，从而 

希望能够导致结果是最好或者最优的算法

2) 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果



### 5.3 贪心算法最佳应用-集合覆盖 

1) 假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有 

的地区都可以接收到信号 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\覆盖地区.png)



2) 思路分析: 

 如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假 

设总的有 n 个广播台，则广播台的组合总共有 2ⁿ -1 个,假设每秒可以计算 10 个子集， 如图

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\各个电台情况.png)

使用贪婪算法，效率高: 

1) 目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择 

策略上，因为需要覆盖全部地区的最小集合: 

2) 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关 

系） 

3) 将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。 

4) 重复第 1 步**直到覆盖了全部的**地区 

分析的图解

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\贪心算法图解.png)



### 5.4 代码：

```
package com.algorithm.algorithm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.function.Function;

public class GreedyAlgorithm {
    public static void main(String[] args) {
        HashMap<String,HashSet<String>> broadcasts = new HashMap();
        //将各个电台放入到 broadcasts
        HashSet<String> hashSet1 = new HashSet<String>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");
        HashSet<String> hashSet2 = new HashSet<String>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");
        HashSet<String> hashSet3 = new HashSet<String>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");
        HashSet<String> hashSet4 = new HashSet<String>();
        hashSet4.add("上海");
        hashSet4.add("天津");
        HashSet<String> hashSet5 = new HashSet<String>();
        hashSet5.add("杭州");
        hashSet5.add("大连");

        //全部放入到Map
        broadcasts.put("K1", hashSet1);
        broadcasts.put("K2", hashSet2);
        broadcasts.put("K3", hashSet3);
        broadcasts.put("K4", hashSet4);
        broadcasts.put("K5", hashSet5);

        //allAreas 存放所有待覆盖的地区
        HashSet<String> allAreas = new HashSet<String>();
        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("天津");
        allAreas.add("广州");
        allAreas.add("深圳");
        allAreas.add("成都");
        allAreas.add("杭州");
        allAreas.add("大连");

        //创建 ArrayList, 存放选择的电台集合
        ArrayList<String> selects = new ArrayList<String>();

        //临时存放每次查询出的电台覆盖的区域的集合
        HashSet<String> tempSet = new HashSet<>();

        //标识每次循环得到的最大覆盖范围的电台KEY
        String maxKey = null;
        int maxSize=0;

        while (allAreas.size() != 0) {
            //每次循环是初始化
            maxKey=null;
            maxSize=0;

            for (String key : broadcasts.keySet()) {
                //每次循环清空临时集合
                tempSet.clear();

                HashSet<String> broads = broadcasts.get(key);
                //将元素全部放到临时集合中
                tempSet.addAll(broads);
                //求出临时集合和当前所有未覆盖地区交集
                tempSet.retainAll(allAreas);

                //如果maxKey是空，或者新的电台key最大覆盖区域大于原来的MaxKey
                if (tempSet!=null && tempSet.size()>0 && (maxKey==null || tempSet.size()>maxSize)){
                    maxKey=key;
                    maxSize=tempSet.size();
                }

            }

            //一次选择结束，将已经覆盖元素从未覆盖元素集合中取出
            allAreas.removeAll(broadcasts.get(maxKey));
            //一次选择结束，将当前最大元素放到集合中
            selects.add(maxKey);

        }


        System.out.println("selects = " + selects);

    }
}
```





### 5.5 贪心算法注意事项和细节 

1) 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果 

2) 比如上题的算法选出的是 K1, K2, K3, K5，符合覆盖了全部的地区 

3) 但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区，如果 K2 的使用成本低于 K1,那么我们上题的 

K1, K2, K3, K5 虽然是满足条件，但是并不是最优的





## 6、普里姆算法 

### 6.1 应用场景-修路问题 

看一个应用场景和问题：

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\村庄问题.png)

**1)** **有胜利乡有** **7** **个村庄****(A, B, C, D, E, F, G)** **，现在需要修路把** **7** **个村庄连通** 

**2)** **各个村庄的距离用边线表示**(权) **，比如** **A** **–** **B** **距离** **5** **公里** 

**3)** **问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短**?

**思路：** **将** **10** **条边，连接即可，但是总的里程数不是最小**.

**正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少**.





### 6.2 最小生成树 

修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称MST。
1、给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 
2、N个顶点，一定有N-1条边
3、包含全部顶点
4、N-1条边都在图中
5、举例说明(如图:)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\最小生成树.png)

6、求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法



### 6.3 普里姆算法介绍

**普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图**
普利姆的算法如下:

1、设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 
2、若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1
3、若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1
4、重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边
5、提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解.

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\普里姆算法图解.png)



### 6.4 普里姆算法最佳实践(修路问题)

题干见6.1



```
package com.algorithm.algorithm;

import java.util.Arrays;

public class PrimAlgorithm {
    public static void main(String[] args) {
        char[] data = new char[]{'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int verxs = data.length;

        //邻接矩阵的关系使用二维数组表示,10000 这个大数，表示两个点不联通
        int[][] weight = new int[][]{{10000, 5, 7, 10000, 10000, 10000, 2}, {5, 10000, 10000, 9, 10000, 10000, 3}, {7, 10000, 10000, 10000, 8, 10000, 10000}, {10000, 9, 10000, 10000, 10000, 4, 10000}, {10000, 10000, 8, 10000, 10000, 5, 4}, {10000, 10000, 10000, 4, 5, 10000, 6}, {2, 3, 10000, 10000, 4, 6, 10000},};

        //创建 MGraph 对象
        MGraph graph = new MGraph(verxs);

        //创建一个 MinTree 对象
        MinTree minTree = new MinTree();
        minTree.createGraph(graph,verxs,data,weight);
        minTree.showGraph(graph);
        minTree.prim(graph,0);
    }
}

class MinTree {

    /***
     *
     * @param graph
     * @param vertex
     * @param data
     * @param weight
     */
    public void createGraph(MGraph graph, int vertex, char[] data, int[][] weight) {
        for (int i = 0; i < vertex; i++) {
            graph.data[i] = data[i];

            for (int j = 0; j < vertex; j++) {
                graph.weight[i][j] = weight[i][j];
            }
        }


    }


    /**
     * 打印出当前图的边界连接情况
     *
     * @param graph 图
     */
    public void showGraph(MGraph graph) {
        for (int[] line : graph.weight) {
            System.out.println(Arrays.toString(line));
        }

    }


    /**
     * 按照普里姆算法生成最小树
     *
     * @param graph 图
     * @param v     表示从图的第几个顶点开始生成'A'->0 'B'->1...
     */
    public void prim(MGraph graph, int v) {
        //数组标识每个节点是否已经被访问 1：已访问  0 未访问
        int[] visited = new int[graph.vertex];

        //节点v标识为已访问
        visited[v] = 1;

        //标识两个边的节点下标
        int h1 = -1;
        int h2 = -1;

        //标志一个最大的min,找到每一轮最小的数据
        int minWeigh = 10000;


        for (int k = 1; k < graph.vertex; k++) {  //根据普利姆算法，n个顶点会生产n-1个边

            //求出每个边的最小值
            for (int i = 0; i < graph.vertex; i++) { // i 结点表示被访问过的结点
                for (int j = 0; j < graph.vertex; j++) {//j 结点表示还没有访问过的结点
                    //替换 minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边)
                    if (visited[i] == 1 && visited[j] == 0 && graph.weight[i][j] < minWeigh) {
                        minWeigh = graph.weight[i][j];
                        h1 = i;
                        h2 = j;
                    }

                }
            }

            System.out.printf("第%d轮，找到最小边：<%s，%s>", k, graph.data[h1], graph.data[h2]);
            System.out.println();

            //将这一轮找到的最小边的节点标志为已访问
            visited[h2] = 1;

            //重置minWeight，用于新一轮计划
            minWeigh = 10000;


        }


    }


}


class MGraph {
    int vertex; //节点个数

    char[] data; //节点数组

    int[][] weight; //存放边的数据

    public MGraph(int vertex) {
        this.vertex = vertex;
        this.data = new char[vertex];
        this.weight = new int[vertex][vertex];
    }
}
```



## 7、克鲁斯卡尔算法 

### 7.1 应用场景-公交站问题

看一个应用场景和问题： 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\克鲁斯卡尔算法问题.png)

1、某城市新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通
2、各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里
3、问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?



### 7.2 克鲁斯卡尔算法介绍

1) 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 

2) 基本思想：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路 

3) 具体做法：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森 

林中不产生回路，直至森林变成一棵树为止



### 7.3 克鲁斯卡尔算法图解说明 

以城市公交站问题来图解说明 克鲁斯卡尔算法的原理和步骤：

#### 7.3.1、问题分析

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\克鲁斯卡尔问题分析.png)



#### **7.3.2、克鲁斯卡尔算法图解**

以上图G4为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\克鲁斯卡尔问题图解.png)

**第1步**：将边<E,F>加入R中。 边<E,F>的权值最小，因此将它加入到最小生成树结果R中。 
**第2步**：将边<C,D>加入R中。 上一步操作之后，边<C,D>的权值最小，因此将它加入到最小生成树结果R中。 
**第3步**：将边<D,E>加入R中。 上一步操作之后，边<D,E>的权值最小，因此将它加入到最小生成树结果R中。 
**第4步**：将边<B,F>加入R中。 上一步操作之后，边<C,E>的权值最小，但<C,E>会和已有的边构成回路；因此，跳过边<C,E>。同理，跳过边<C,F>。将边<B,F>加入到最小生成树结果R中。 
**第5步**：将边<E,G>加入R中。 上一步操作之后，边<E,G>的权值最小，因此将它加入到最小生成树结果R中。 
**第6步**：将边<A,B>加入R中。  上一步操作之后，边<F,G>的权值最小，但<F,G>会和已有的边构成回路；因此，跳过边<F,G>。同理，跳过边<B,C>。将边<A,B>加入到最小生成树结果R中。此时，最小生成树构造完成！它包括的边依次是：<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。



#### **7.4.3克鲁斯卡尔算法分析**

根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题： 
**问题一** 对图的所有边按照权值大小进行排序。 
**问题二** 将边添加到最小生成树中时，怎么样判断是否形成了回路。

问题一很好解决，采用排序算法进行排序即可。

问题二，处理方式是：记录顶点在"最小生成树"中的终点，顶点的终点是"在最小生成树中与它连通的最大顶点"。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。



#### **7.4.4如何判断是否构成回路****-举例说明(如图)**

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\克鲁斯卡尔-回路.png)

在将<E,F> <C,D> <D,E>加入到最小生成树R中之后，这几条边的顶点就都有了终点：

**(01)** C的终点是F。 
**(02)** D的终点是F。 
**(03)** E的终点是F。 
**(04)** F的终点是F。

关于终点的说明：

1) 就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是"与它连通的最大顶点"。 

2) 因此，接下来，虽然<C,E>是权值最小的边。但是C和E的终点都是F，即它们的终点相同，因此，将<C,E>加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。【后面有代码说明】





### 7.4、代码汇总

关键是理解这行代码：

```
ends[p1End]=p2End; 
```

```java
package com.algorithm.algorithm;

import java.util.Arrays;

public class KruskalCase {
    private int edgeNums; //边的个数
    private char[] vertex; //顶点数组
    private int[][] matrix; //邻接矩阵
    private static final int INF=Integer.MAX_VALUE;

    public static void main(String[] args) {
        char[] vertexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        //克鲁斯卡尔算法的邻接矩阵
        int matrix[][] = { /*A*//*B*//*C*//*D*//*E*//*F*//*G*/
                /*A*/ { 0, 12, INF, INF, INF, 16, 14},
                /*B*/ { 12, 0, 10, INF, INF, 7, INF},
                /*C*/ { INF, 10, 0, 3, 5, 6, INF},
                /*D*/ { INF, INF, 3, 0, 4, INF, INF},
                /*E*/ { INF, INF, 5, 4, 0, 2, 8},
                /*F*/ { 16, 7, 6, INF, 2, 0, 9},
                /*G*/ { 14, INF, INF, INF, 8, 9, 0}};

        KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);
        //输出构建的
        kruskalCase.print();
        kruskalCase.kruskal();
    }


    public KruskalCase(char[] vertex, int[][] matrix) {
        //采用复制的方式
        int vlen=vertex.length; //顶点个数

        //复制顶点数组
        this.vertex=new char[vlen];
        for (int i = 0; i <vertex.length ; i++) {
            this.vertex[i]=vertex[i];
        }

        //复制邻接数组
        this.matrix=new int[vlen][vlen];
        for (int i = 0; i < vlen; i++) {
            for (int j = 0; j <vlen ; j++) {
                this.matrix[i][j]=matrix[i][j];
            }
        }

        //统计边条数
        for (int i = 0; i < vlen; i++) {
            for (int j = i+1; j <vlen ; j++) {
                if (matrix[i][j] != INF) {
                    edgeNums++;
                }
            }
        }
    }


    public void kruskal() {

        EData[] res= new EData[edgeNums]; //保存得到的最小生成树的边结果

        //标志每一个顶点的终点
        int[] ends=new int[vertex.length];

        //获取所有的边集合
        EData[] edges = getEdges();

        //边排序
        sortEdge(edges);

        //结果集下标
        int k=0;

        //遍历每一条边，如果没有构成回路，把这条边加入结果数组
        for (int i = 0; i <edgeNums ; i++) {
            int p1=getPosition(edges[i].start); //边的起点
            int p2=getPosition(edges[i].end); //边的终点

            int p1End=getEnd(ends,p1); //边起点的终点
            int p2End=getEnd(ends,p2); //边终点的终点

            //如果没有构成回路
            if (p1End != p2End) {
                //注意，很重要。不是设置p1的终点为p2
                ends[p1End]=p2End;   //起点p1的终点设为p2
                res[k++]=edges[i];   //将这条边加入结果集
            }

        }

        //<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。
        // 统计并打印 "最小生成树", 输出 rets
        for (int i = 0; i <k ; i++) {
            System.out.println(res[i]);
        }


        // 统计并打印各个顶点的终点, 输出 rets
        for (int i = 0; i <ends.length ; i++) {
            System.out.println(ends[i]);
        }


    }

    /**
     * 获取已生成的最小生成树的顶点的终点
     * @param ends 记录所有顶点的终点。  初始时均为0，也就是终点是本身。
     *             举例：如果end[1] 为B, 终点是C.那么end[1]=2.如果B的终点是D,那么end[1]=3
     * @param index 待查找终点的顶点的数组下标
     * @return 终点在数组中的下标
     */
    public int getEnd(int[] ends, int index) {
        while (ends[index] != 0) {
            index=ends[index];
        }

        return index;
    }


    /**
     * 获取每个顶点对应的下标
     * @param v 顶点字符
     * @return 顶点数组下标
     */
    public int getPosition(char v) {
        for (int i = 0; i < vertex.length; i++) {
            if (vertex[i] == v) {
                return i;
            }
        }

        return -1;


    }



    /**
     * 对边进行冒泡排序
     * @param edges
     */
    public void sortEdge(EData[] edges) {

        for (int i = 0; i <edges.length-1 ; i++) {
            for (int j = 0; j <edges.length-i-1 ; j++) {
                if (edges[j].weight > edges[j + 1].weight) {
                    EData temp=edges[j];
                    edges[j]=edges[j+1];
                    edges[j+1]=temp;
                }
            }
        }


    }

    public EData[] getEdges() {
        //标识边数组下标
        int n=0;

        EData[] edges = new EData[edgeNums];

        //统计边条数
        for (int i = 0; i < this.matrix.length; i++) {
            for (int j = i+1; j <this.matrix[0].length ; j++) {
                if (matrix[i][j] != INF) {
                    EData edge = new EData(this.vertex[i], this.vertex[j], matrix[i][j]);
                    edges[n++]=edge;
                }
            }
        }

        return edges;
    }

    //打印邻接矩阵
    public void print() {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                System.out.printf("%12d",matrix[i][j]);
            }
            System.out.println();
        }
    }


    static class EData{
        public char start; //边的起点
        public char end; //边的终点
        public int weight; //边的权值

        public EData(char start, char end, int weight) {
            this.start = start;
            this.end = end;
            this.weight = weight;
        }

        @Override
        public String toString() {
            return "EData{" +
                    "start=" + start +
                    ", end=" + end +
                    ", weight=" + weight +
                    '}';
        }
    }
}
```





## 8、迪杰斯特拉算法 

### 8.1 应用场景-最短路径问题 

看一个应用场景和问题：

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\村庄问题.png)

1) 战争时期，胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 

A, B, C , D, E, F 六个村庄 

2) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 

3) 问：如何计算出 G 村庄到 其它各个村庄的最短距离? 

4) 如果从其它点出发到各个点的最短距离又是多少?



### 8.2 迪杰斯特拉(Dijkstra)算法介绍 

迪杰斯特拉(Dijkstra)算法是**典型最短路径算法**，用于计算一个结点到其他结点的最短路径。它的主要特点是以 

起始点为中心向外层层扩展(**广度优先搜索思想**)，直到扩展到终点为止。 



### 8.3 迪杰斯特拉(Dijkstra)算法过程 

1) 设置出发顶点为 v，顶点集合 V{v1,v2,vi...}，v 到 V 中各顶点的距离构成距离集合 Dis，Dis{d1,d2,di...}，Dis 

集合记录着 v 到图中各顶点的距离(到自身可以看作 0，v 到 vi 距离对应为 di) 

2) 从 Dis 中选择值最小的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径

3) 更新 Dis 集合，更新规则为：比较 v 到 V 集合中顶点的距离值，与 v 通过 vi 到 V 集合中顶点的距离值，保留 

值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的) 

4) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束



### 8.4 迪杰斯特拉(Dijkstra)算法最佳应用-最短路径 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\村庄问题.png)

1) 战争时期，胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 

A, B, C , D, E, F 六个村庄 

2) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 

3) 问：如何计算出 G 村庄到 其它各个村庄的最短距离? 

4) 如果从其它点出发到各个点的最短距离又是多少? 

5) 使用图解的方式分析了迪杰斯特拉(Dijkstra)算法 思路

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\迪杰斯特拉算法图解.png)



### 8.5 代码：

```
package com.algorithm.algorithm;

import com.sun.corba.se.impl.orbutil.graph.Graph;

import java.util.Arrays;

public class DijkstraAlgorithm {

    private char[] vertex; //顶点数组
    private int[][] matrix; //邻接矩阵
    private VisitedVertex vv; //已访问顶点




    public static void main(String[] args) {
        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
        //邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535; ;// 表示两个节点不连通

        matrix[0]=new int[]{N,5,7,N,N,N,2};
        matrix[1]=new int[]{5,N,N,9,N,N,2};
        matrix[2]=new int[]{7,N,N,N,8,N,N};
        matrix[3]=new int[]{N,9,N,N,N,4,N};
        matrix[4]=new int[]{N,N,8,N,N,5,4};
        matrix[5]=new int[]{N,N,N,4,5,N,6};
        matrix[6]=new int[]{2,2,N,N,4,6,N};
        //创建 Graph 对象
        DijkstraAlgorithm graph = new DijkstraAlgorithm(vertex, matrix);
        //测试, 看看图的邻接矩阵是否 ok
        graph.showGraph();
        //测试迪杰斯特拉算法
        graph.djs(0);//C
        graph.showDijkstra();
    }

    public DijkstraAlgorithm(char[] vertex, int[][] matrix) {
        this.vertex = vertex;
        this.matrix = matrix;
    }


    /**
     * 打印邻接矩阵
     */
    public void showGraph() {
        for (int i = 0; i <matrix.length ; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }

    public void djs(int index) {
        //初始化已访问实例
        vv = new VisitedVertex(vertex.length, index);

        //更新出发节点到其他节点的距离
        update(index);

        //遍历循环下一次访问的点
        for (int i = 0; i <vertex.length ; i++) {
            int next = vv.updateArr();
            update(next);

        }


    }


    public void update(int index) {
        int len=0;
        for (int i = 0; i <matrix[index].length ; i++) {
            len=vv.dis[index]+matrix[index][i];   //当前访问节点到其他节点的距离
            if (!vv.hasVisited(i) && len < vv.dis[i]) {
                vv.updatePreVertex(i,index);  //更新前驱节点
                vv.updateDis(i,len);  //更新出发节点到这个节点的距离
            }
        }
    }

    //显示结果
    public void showDijkstra() {
        vv.show();
    }






    static class VisitedVertex{
        private  int[] visited_vertex; //已访问顶点数组
        private  int[] pre_vertex; //前驱顶点
        private  int[] dis; //记录出发顶点到其他顶点的举例

        /**
         * 初始化已访问类节点
         * @param length 节点数量
         * @param index 出发顶点下标
         */
        public VisitedVertex(int length, int index) {
            this.visited_vertex = new int[length];  // 记录各个顶点是否作为访问节点访问过 1 表示访问过,0 未访问,会动态更新
            this.pre_vertex = new int[length];
            this.dis = new int[length];

            //一开始距离设为最大值，表示出发顶点和其他顶点不连通
            Arrays.fill(dis,65535);
            dis[index]=0;

            //出发顶点设为 1-已访问
            visited_vertex[index]=1;


        }

        /**
         * 查看该节点是否已经访问过了
         * @param index 待查询数组下标
         * @return
         */
        public boolean hasVisited(int index) {
            return visited_vertex[index]==1;
        }

        public void updatePreVertex(int index, int preVertex) {
            pre_vertex[index]=preVertex;
        }


        public void updateDis(int index, int len) {
            dis[index]=len;
        }


        /**
         *
         */
        public int updateArr() {
            int min=65535;

            int index = 0; //下一步应该访问的节点下标
            for (int i = 0; i < visited_vertex.length; i++) {
                if (visited_vertex[i] == 0 && dis[i] < min) {  //包含一个隐藏条件，dis<Integer.MAX意味着这个已经节点已经在之前和出发节点测过距离了
                    min=dis[i];
                    index=i;
                }
            }

            visited_vertex[index] = 1;
            return index;
        }

        public void show() {
            System.out.println("==========================");
            //输出 already_arr
            for(int i : visited_vertex) {
                System.out.print(i + " ");
            }
            System.out.println();

            //输出 visited_vertex
            for(int i : visited_vertex) {
                System.out.print(i + " ");
            }

            System.out.println();

            for(int i : dis) {
                System.out.print(i + " ");
            }
            System.out.println();
            //为了好看最后的最短距离，我们处理
            char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
            int count = 0;
            for (int i : dis) {
                if (i != 65535) {
                    System.out.print(vertex[count] + "("+i+") ");
                } else {
                    System.out.println("N ");
                }
            }
            count++;

            System.out.println();
            }

    }




}
```





## 9 弗洛伊德算法 

### 9.1 弗洛伊德(Floyd)算法介绍 

1) 和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法 

名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名 

2) 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径 

3) 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 

4) 弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点 

的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每 

一个顶点到其他顶点的最短路径。



### 9.2 弗洛伊德(Floyd)算法图解分析 

1) 设置顶点 vi 到顶点 vk 的最短路径已知为 Lik，顶点 vk 到 vj 的最短路径已知为 Lkj，顶点 vi 到 vj 的路径为 Lij， 

则 vi 到 vj 的最短路径为：min((Lik+Lkj),Lij)，vk 的取值为图中所有顶点，则可获得 vi 到 vj 的最短路径 

2) 至于 vi 到 vk 的最短路径 Lik 或者 vk 到 vj 的最短路径 Lkj，是以同样的方式获得

3) 弗洛伊德(Floyd)算法图解分析-举例说明

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\弗洛伊德算法分析.png)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\弗洛伊德算法分析2.png)





### 9.3 完整代码：

```
package com.algorithm.algorithm;

import com.sun.corba.se.impl.orbutil.graph.Graph;

import java.util.Arrays;

public class FloydAlgorithm {
    public static void main(String[] args) {
        // 测试看看图是否创建成功
        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
        //创建邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;
        matrix[0] = new int[] { 0, 5, 7, N, N, N, 2 };
        matrix[1] = new int[] { 5, 0, N, 9, N, N, 3 };
        matrix[2] = new int[] { 7, N, 0, N, 8, N, N };
        matrix[3] = new int[] { N, 9, N, 0, N, 4, N };
        matrix[4] = new int[] { N, N, 8, N, 0, 5, 4 };
        matrix[5] = new int[] { N, N, N, 4, 5, 0, 6 };
        matrix[6] = new int[] { 2, 3, N, N, 4, 6, 0 };

        //创建 Graph 对象
        Graph1 graph = new Graph1(vertex.length, vertex, matrix);
        //调用弗洛伊德算法
        graph.floyd();
        graph.show();
    }
}

//图
class Graph1 {
    private char[] vertex; //顶点
    private int[][] dis; //邻接矩阵
    private int[][] pre; //前驱节点

    public Graph1(int length, char[] vertex, int[][] dis) {
        this.vertex = vertex;
        this.dis = dis;
        this.pre=new int[length][length];

        //初始化前驱数组
        for (int i = 0; i <length ; i++) {
            Arrays.fill(pre[i],i);
        }
    }


    public void show() {

        for (int k = 0; k < vertex.length; k++) {
            for (int j = 0; j < vertex.length; j++) {
                System.out.print(vertex[pre[k][j]]+"");
            }

            System.out.println();

            for (int i = 0; i <vertex.length ; i++) {
                System.out.println("顶点:"+vertex[k]+"到顶点"+vertex[i]+"的距离："+dis[k][i]);
            }
            System.out.println();

        }
        
        
    }

    public void floyd() {
        int len=0;
        for (int i = 0; i < vertex.length; i++) {
            for (int j = 0; j < vertex.length; j++) {
                for (int k = 0; k < vertex.length; k++) {
                  len=dis[j][i]+dis[i][k];
                    if (len < dis[j][k]) {
                        dis[j][k]=len;  //如果借用中间点i, jk之间的距离减小了。用新的具体替换距离表
                        pre[j][k]=pre[i][k];  //jk之间的距离的前驱节点修改为i
                    }
                }
            }
        }
        
        
        
        
    }
}
```





## 10 马踏棋盘算法 

### 10.1 马踏棋盘算法介绍和游戏演示 

1) 马踏棋盘算法也被称为骑士周游问题 

2) 将马随机放在国际象棋的 8×8 棋盘 Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求 

每个方格只进入一次，走遍棋盘上全部 64 个方格 

3) 游戏演示: http://www.4399.com/flash/146267_2.htm

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\马踏棋盘算法.png)





### 10.2 马踏棋盘游戏代码实现 

1) 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。 

2) 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发 

现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… 

**思路分析**+代码 

实现 

对第一种实现方式的思路图解

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\骑士周游算法分析.png)



3) 分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题.

![](D:\java oracle\学习资料\各种学习整理文档（重要）\算法\算法实现\photos\骑士周游算法贪心优化.png)





### 10.3 代码实现

//关键点：需要厘清棋盘上的row， coll分别是横向和纵向。 在point中分别是指point.y, point.x

```
package com.algorithm.algorithm;

import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;

public class HorseChessBoard {
    private int X;
    private int Y;
    private boolean[] visited; //标识棋盘上某个位置是否已经被访问
    private boolean finished=false; //标识整个查找是否结束

    public static void main(String[] args) {
        System.out.println("骑士周游算法，开始运行~~");
        //测试骑士周游算法是否正确
        int row = 1; //马儿初始位置的行，从 1 开始编号
        int column = 1; //马儿初始位置的列，从 1 开始编号

        int X = 8;
        int Y = 8;
        //创建棋盘
        int[][] chessboard = new int[X][Y];

        HorseChessBoard horseChessBoard = new HorseChessBoard(chessboard,X,Y);

        //测试一下耗时
        long start = System.currentTimeMillis();
        horseChessBoard.traversalChessboard(chessboard, row - 1, column - 1, 1);
        long end = System.currentTimeMillis();
        System.out.println("共耗时: " + (end - start) + " 毫秒");

        for(int[] rows : chessboard) {
            for(int step: rows) {
                System.out.print(step + "\t");
            }System.out.println();
        }

    }

    public HorseChessBoard(int[][] chessBoard, int X, int Y) {
        this.visited = new boolean[X * Y];//初始值都是 false
        this.X=X;
        this.Y=Y;
    }

    /**
     * 骑士走到当前所在位置是做的处理
     * @param chessBoard
     * @param row 当前位置棋盘的Y坐标值
     * @param coll 当前位置棋盘的X坐标值
     * @param step 当前是第几步
     */
    public  void traversalChessboard(int[][] chessBoard, int row, int coll, int step){

        //标识该point（row,coll）点是第几步
        chessBoard[row][coll]=step;
        //标识该点已经被访问过
        this.visited[row*X+coll]=true;
        //查找当前点point(row, coll)下一个可访问的所有点
        ArrayList<Point> points = nextPoints(coll,row);
        sort(points);
        //循环遍历所有可以访问的节点
        while (points.size() > 0) {
            Point point = points.remove(0);
            //这一位置还没走过
            if (!visited[point.y * X + point.x]) {
                traversalChessboard(chessBoard, point.y, point.x, step+1);  //迭代走下一个位置
            }
        }

        //如果走到最后一步发现没有走不同，将当前所在位置标识为还原
        if (step < X * Y && !finished) {
            chessBoard[row][coll]=0;
            this.visited[row*X+coll]=false;
        }else {
            this.finished=true;
        }

    }


    /**
     * 查询当前点在棋盘上所有接下来可以访问的点
     * @param row 当前点横坐标
     * @param coll 当前点纵坐标
     * @return 当前位置下一步所有可以访问的点
     */
    private  ArrayList<Point> nextPoints(int row, int coll) {
        ArrayList<Point> points = new ArrayList<>();

        Point point = new Point();

        //5号点所在位置
        if ((point.x = (row - 2)) >= 0 && (point.y = (coll - 1)) >= 0) {
            points.add(new Point(point));
        }

        //6号点所在位置
        if ((point.x = (row - 1)) >= 0 && (point.y = (coll - 2)) >= 0) {
            points.add(new Point(point));
        }

        //7号点所在位置
        if ((point.x = (row + 1)) < this.X && (point.y = (coll - 2)) >= 0) {
            points.add(new Point(point));
        }

        //0号点所在位置
        if ((point.x = (row + 2)) <X && (point.y = (coll - 1)) >= 0) {
            points.add(new Point(point));
        }

        //1号点所在位置
        if ((point.x = (row + 2)) <X && (point.y = (coll + 1)) < Y) {
            points.add(new Point(point));
        }

        //2号点所在位置
        if ((point.x = (row + 1)) < X && (point.y = (coll + 2)) < Y) {
            points.add(new Point(point));
        }

        //3号点所在位置
        if ((point.x = (row - 1)) >= 0 && (point.y = (coll +2)) < Y) {
            points.add(new Point(point));
        }

        //4号点所在位置
        if ((point.x = (row - 2)) >= 0 && (point.y = (coll + 1)) <Y) {
            points.add(new Point(point));
        }

        return points;
    }


    /**
     * 排序
     * @param points
     */
    private void sort(ArrayList<Point> points) {
        points.sort(new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                int n1 = nextPoints(o1.x, o1.y).size();
                int n2 = nextPoints(o2.x, o2.y).size();

                if (n1 < n2) {
                    return -1;
                } else if (n1 == n2) {
                    return 0;
                }else {
                    return 1;
                }
            }
        });


    }


}
```



骑士周游算法，开始运行~~
共耗时: 18 毫秒
1	16	37	32	3	18	47	22	
38	31	2	17	48	21	4	19	
15	36	49	54	33	64	23	46	
30	39	60	35	50	53	20	5	
61	14	55	52	63	34	45	24	
40	29	62	59	56	51	6	9	
13	58	27	42	11	8	25	44	
28	41	12	57	26	43	10	7	

