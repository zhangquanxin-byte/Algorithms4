# 							JVM虚拟机



## 1、Java内存区域

### **1.1** **概述**

对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一

个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序

员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样

使用内存的，那么排查错误将会是一个非常艰巨的任务。

### **1.2** **运行时数据区域**

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之

前的版本略有不同，下面会介绍到。

**JDK 1.8** **之前**

![](D:\java oracle\学习资料\各种学习整理文档（重要）\JVM虚拟机\photos\jdk1.8之前内存模型.png)

JDK1.8

![](D:\java oracle\学习资料\各种学习整理文档（重要）\JVM虚拟机\photos\jdk1.8内存模型.png)



**线程私有的：**

程序计数器

虚拟机栈

本地方法栈

**线程共享的：**

堆

方法区

直接内存 (非运行时数据区的一部分)



### 1.3、线程私有的区域

#### **1.3.1** **程序计数器**

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器**

**工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、**

**线程恢复等功能都需要依赖这个计数器来完成。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之**

**间计数器互不影响，独立存储，我们称这类内存区域为****“****线程私有****”****的内存。**

**从上面的介绍中我们知道程序计数器主要有两个作用：**

\1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选

择、循环、异常处理。

\2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够

知道该线程上次运行到哪儿了。 

JDX制作**注意：程序计数器是唯一一个不会出现** **OutOfMemoryError** **的内存区域，它的生命周期随着线程的创**

**建而创建，随着线程的结束而死亡。**



#### **1.3.2 Java** **虚拟机栈**

**与程序计数器一样，****Java** **虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是** **Java** **方法执**

**行的内存模型，每次方法调用的数据都是通过栈传递的。**

**Java** **内存可以粗糙的区分为堆内存（****Heap****）和栈内存** **(Stack),****其中栈就是现在说的虚拟机栈，或者说**

**是虚拟机栈中局部变量表部分。** （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥

有：局部变量表、操作数栈、动态链接、方法出口信息。）

**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、flfloat、

long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引

用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**Java** **虚拟机栈会出现两种错误：****StackOverFlowError** **和** **OutOfMemoryError****。**

**StackOverFlowError****：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度

超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

**OutOfMemoryError****：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完

了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。

Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随

着线程的死亡而死亡。

**扩展：那么方法****/****函数如何调用？**

Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈

帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java 方法有两种返回方式：

\1. return 语句。

\2. 抛出异常。

不管哪种返回方式都会导致栈帧被弹出。



#### **1.3.3** **本地方法栈**

​		和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行** **Java** **方法 （也就是字节码）服**

**务，而本地方法栈则为虚拟机使用到的** **Native** **方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二

为一。

​		本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数

栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和OutOfMemoryError 两种错误。



### 1.4、公共内存区域

#### 1.4.1、堆

​		Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。Java世界中几乎所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

​		Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC** 堆（Garbage Collected Heap）.从垃圾回收

的角度，由于现在收集器基本都采用**分代垃圾收集算法**，所以 Java 堆还可以细分为：新生代和老年

代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回

收内存，或者更快地分配内存。



在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：

1. 新生代内存(Young Generation)

2. 老生代(Old Generation)

3. 永生代(Permanent Generation)

![](D:\java oracle\学习资料\各种学习整理文档（重要）\JVM虚拟机\photos\堆.png)

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空

间，元空间使用的是直接内存。

![](D:\java oracle\学习资料\各种学习整理文档（重要）\JVM虚拟机\photos\jdk1.8的堆内存模型.png)

**上图所示的** **Eden** **区、两个** **Survivor** **区都属于新生代（为了区分，这两个** **Survivor** **区域按照顺序被**

**命名为** **from** **和** **to****），中间一层属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

修正：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个

年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作

为新的晋升年龄阈值”。



**堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，**

**比如：**

1. OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且

只能回收很少的堆空间时，就会发生此错误。

2. java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间

不足以存放新创建的对象, 就会引发 java.lang.OutOfMemoryError: Java heap space 错误。

(和本机物理内存无关，和你配置的内存大小有关！) 



#### **1.4.2** **方法区**

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静

态变量、即时编译器编译后的代码等数据。虽然 **Java** **虚拟机规范把方法区描述为堆的一个逻辑部分**，

但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。

**1.4.2.1** **方法区和永久代的关系**

《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那

么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像** **Java** **中接口和**

**类的关系，类实现了接口，而永久代就是** **HotSpot** **虚拟机对虚拟机规范中方法区的一种实现方**

**式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，

而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

**1.4.2.2** **常用参数**

JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元

空间，元空间使用的是直接内存。

下面是一些常用参数：

```
size_t desired_survivor_size = (size_t)((((double) 

survivor_capacity)*TargetSurvivorRatio)/100); 

size_t total = 0; 

uint age = 1; 

while (age < table_size) { 

total += sizes[age];//sizes数组是每个年龄段对象大小 

if (total > desired_survivor_size) break; 

age++; 

}

uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold; 

... 

} 
```

-XX:PermSize=N //方法区 (永久代) 初始大小 

-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异 

常:java.lang.OutOfMemoryError: PermGen

JDX制作与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内

存。



**1.4.2.3、** **为什么要将永久代** **(PermGen)** **替换为元空间** **(MetaSpace)** **呢**?

1. 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受

本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

当你元空间溢出时会得到如下错误： java.lang.OutOfMemoryError: MetaSpace

你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值 unlimited，这意味着它只

受系统内存的限制。 -XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则

Metaspace 将根据运行时的应用程序需求动态地重新调整大小。 

2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系

统的实际可用空间来控制，这样能加载的类就更多了。 

3. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没

有必要额外的设置这么一个永久代的地方了。

**1.2.6** **运行时常量池**

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还

有常量池表（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛

出 OutOfMemoryError 错误。

**JDK1.7** **及之后版本的** **JVM** **已经将运行时常量池从方法区中移了出来，在** **Java** **堆（**Heap）中开辟了一

**块区域存放运行时常量池。**

修正：

1. **JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区**,此时hotspot虚拟机对方法区的实现为永久代

2. **JDK1.7** **字符串常量池被从方法区拿到了堆中,** **这里没有提到运行时常量池**,**也就是说字符串常量池被单独拿到堆**,运行时常量池剩下的东西还在方法区, **也就是**hotspot**中的永久代** 。 

3. **JDK1.8 hotspot**移除了永久代用元空间**(Metaspace)*取而代之, **这时候字符串常量池还在堆,

**运行时常量池还在方法区， **只不过方法区的实现从永久代变成了元空间***(Metaspace)



#### **1.2.3** **直接内存**

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存**

**也被频繁地使用。而且也可能导致** **OutOfMemoryError** **错误出现。**

JDK1.4 中新加入的 **NIO(New Input/Output)** **类**，引入了一种基于**通道（**Channel） 与**缓存区**

（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java

堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因

为**避免了在** **Java** **堆和** **Native** **堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器

寻址空间的限制。





## 2、Java的类加载机制

Java的类加载机制是技术体系中比较核心的部分，虽然它和我们直接打交道不多，但是对其背后的机理有一定理解有助于我们排查程序中出现的类加载失败等技术问题。 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\JVM虚拟机\photos\类加载过程.png)

　一个java文件从被加载到被卸载这个生命过程，总共要经历5个阶段，JVM将类加载过程分为： （加链初使卸）
　　**加载->链接（验证+准备+解析）->初始化（使用前的准备）->使用->卸载** 

### 2.1、加载 

　1. 通过全类名获取定义此类的二进制字节流

2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构

3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口

虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如："通过全类名获取定义此类的二进制字节

流" 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、

EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。

**一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们**

**可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的** loadClass() **方**

**法）。数组类型不通过类加载器创建，它由** **Java** **虚拟机直接创建。**



### 2.2 、连接

####   2.2.1、验证

确保被加载类的正确性； 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\JVM虚拟机\photos\类加载过程的验证.png)



#### 	2.2.2、准备

​	为类的静态变量分配内存，并将其初始化为默认值

  **准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。对于该

阶段有以下几点需要注意：

1. 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时

随着对象一块分配在 Java 堆中。

2. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们

定义了 public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fifianl 关键字 public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。

**基本数据类型的零值：** 

![](D:\java oracle\学习资料\各种学习整理文档（重要）\JVM虚拟机\photos\数据类型的零值.png)

　　



#### 2.2.3、解析

把类中的符号引用转换为直接引用； 

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、

类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。

**符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移**

**量或一个间接定位到目标的句柄**。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行

方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中

所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用

该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以

被调用。

综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法

在内存中的指针或者偏移量。



### 2.3、初始化

为类的静态变量赋予正确的初始值 

初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构

造器 <clinit> () 方法的过程。对于 <clinit>（） 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <clinit>（）方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发

现。


（1）类什么时候才被初始化 
　　1）创建类的实例，也就是new一个对象 
　　2）访问某个类或接口的静态变量，或者对该静态变量赋值 
　　3）调用类的静态方法 
　　4）反射（Class.forName(“com.lyj.load”)） 
　　5）初始化一个类的子类（会首先初始化子类的父类） 
　　6）JVM启动时标明的启动类，即文件名和类名相同的那个类 
（2）类的初始化顺序 
　　1）如果这个类还没有被加载和链接，那先进行加载和链接 
　　2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口） 
　　3）加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。 

　　4）总的来说，初始化顺序依次是：（静态变量、静态初始化块）–>（变量、初始化块）–> 构造器；

如果有父类，则顺序是：父类static方法 –> 子类static方法 –> 父类构造方法- -> 子类构造方法 











## **3.** **类加载器**

**6.1** **回顾一下类加载过程**

类加载过程：**加载****->****连接****->****初始化**。连接过程又可分为三步:**验证****->****准备****->****解析**。

一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们

可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方

法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。

所有的类都由类加载器加载，加载的作用就是将 .class文件加载到内存。



**6.2** **类加载器总结**

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全

部继承自 java.lang.ClassLoader ： 

1. **BootstrapClassLoader(****启动类加载器****)** ：最顶层的加载类，由C++实现，负责加载

%JAVA_HOME%/lib 目录下的jar包和类或者或被 -Xbootclasspath 参数指定的路径中的所有类。

2. **ExtensionClassLoader(****扩展类加载器****)** ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar

包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。

3. **AppClassLoader(****应用程序类加载器****)** :面向我们用户的加载器，负责加载当前应用classpath下的

所有jar包和类。

**6.3** **双亲委派模型**

**6.3.1** **双亲委派模型介绍**

每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 **双亲委派模**

**型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会

尝试加载。加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最

终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自

己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。